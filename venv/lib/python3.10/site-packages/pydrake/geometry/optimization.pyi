import flags
import numpy
import os
import pydrake.common
import pydrake.geometry
import pydrake.math
import pydrake.solvers
import pydrake.symbolic
from pydrake.common.cpp_template import CSpaceSeparatingPlane_ as CSpaceSeparatingPlane_
from typing import Any, ClassVar, Dict, List, Optional, Tuple, overload

class AffineBall(ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, B: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], center: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    @overload
    def __init__(self, ellipsoid: Hyperellipsoid) -> None: ...
    def B(self) -> numpy.ndarray[numpy.float64[m, n]]: ...
    def Clone(self) -> ConvexSet: ...
    @classmethod
    def MakeAxisAligned(cls, radius: numpy.ndarray[numpy.float64[m, 1]], center: numpy.ndarray[numpy.float64[m, 1]]) -> AffineBall: ...
    @classmethod
    def MakeHypersphere(cls, radius: float, center: numpy.ndarray[numpy.float64[m, 1]]) -> AffineBall: ...
    @classmethod
    def MakeUnitBall(cls, dim: int) -> AffineBall: ...
    @classmethod
    def MinimumVolumeCircumscribedEllipsoid(cls, points: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], rank_tol: float = ...) -> AffineBall: ...
    def center(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def __copy__(self) -> ConvexSet: ...
    def __deepcopy__(self, arg0: dict) -> ConvexSet: ...

class AffineSubspace(ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], translation: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    @overload
    def __init__(self, set: ConvexSet, tol: float = ...) -> None: ...
    def AffineDimension(self) -> int: ...
    def Clone(self) -> ConvexSet: ...
    def ContainedIn(self, other: AffineSubspace, tol: float = ...) -> bool: ...
    def IsNearlyEqualTo(self, other: AffineSubspace, tol: float = ...) -> bool: ...
    def OrthogonalComplementBasis(self) -> numpy.ndarray[numpy.float64[m, n]]: ...
    def Project(self, x: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -> numpy.ndarray[numpy.float64[m, n]]: ...
    def ToGlobalCoordinates(self, y: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -> numpy.ndarray[numpy.float64[m, n]]: ...
    @overload
    def ToLocalCoordinates(self, x: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -> numpy.ndarray[numpy.float64[m, n]]: ...
    @overload
    def ToLocalCoordinates(self, x) -> Any: ...
    def basis(self) -> numpy.ndarray[numpy.float64[m, n]]: ...
    def translation(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def __copy__(self) -> ConvexSet: ...
    def __deepcopy__(self, arg0: dict) -> ConvexSet: ...

class CIrisCollisionGeometry:
    def __init__(self, *args, **kwargs) -> None: ...
    def X_BG(self) -> pydrake.math.RigidTransform: ...
    def body_index(self, *args, **kwargs): ...
    def geometry(self) -> pydrake.geometry.Shape: ...
    def id(self) -> pydrake.geometry.GeometryId: ...
    def num_rationals(self) -> int: ...
    def type(self) -> CIrisGeometryType: ...

class CIrisGeometryType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kCapsule: ClassVar[CIrisGeometryType] = ...
    kCylinder: ClassVar[CIrisGeometryType] = ...
    kPolytope: ClassVar[CIrisGeometryType] = ...
    kSphere: ClassVar[CIrisGeometryType] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CSpaceSeparatingPlane:
    def __init__(self, *args, **kwargs) -> None: ...
    def __copy__(self) -> CSpaceSeparatingPlane: ...
    def __deepcopy__(self, arg0: dict) -> CSpaceSeparatingPlane: ...
    @property
    def a(self) -> numpy.ndarray[object[3, 1]]: ...
    @property
    def b(self) -> pydrake.symbolic.Polynomial: ...
    @property
    def decision_variables(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    @property
    def expressed_body(self): ...
    @property
    def negative_side_geometry(self) -> CIrisCollisionGeometry: ...
    @property
    def plane_degree(self) -> int: ...
    @property
    def positive_side_geometry(self) -> CIrisCollisionGeometry: ...

class CSpaceSeparatingPlane_𝓣Variable𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __copy__(self) -> CSpaceSeparatingPlane_TVariableU: ...
    def __deepcopy__(self, arg0: dict) -> CSpaceSeparatingPlane_TVariableU: ...
    @property
    def a(self) -> numpy.ndarray[object[3, 1]]: ...
    @property
    def b(self) -> pydrake.symbolic.Polynomial: ...
    @property
    def decision_variables(self) -> numpy.ndarray[object[m, 1]]: ...
    @property
    def expressed_body(self): ...
    @property
    def negative_side_geometry(self) -> CIrisCollisionGeometry: ...
    @property
    def plane_degree(self) -> int: ...
    @property
    def positive_side_geometry(self) -> CIrisCollisionGeometry: ...

class CartesianProduct(ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, sets: List[ConvexSet]) -> None: ...
    @overload
    def __init__(self, setA: ConvexSet, setB: ConvexSet) -> None: ...
    @overload
    def __init__(self, sets: List[ConvexSet], A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    @overload
    def __init__(self, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = ...) -> None: ...
    def factor(self, index: int) -> ConvexSet: ...
    def num_factors(self) -> int: ...

class ConvexSet:
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def AddPointInNonnegativeScalingConstraints(self, prog: pydrake.solvers.MathematicalProgram, x: numpy.ndarray[object[m, 1]], t: pydrake.symbolic.Variable) -> List[pydrake.solvers.BindingTConstraintU]: ...
    @overload
    def AddPointInNonnegativeScalingConstraints(self, prog: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], c: numpy.ndarray[numpy.float64[m, 1]], d: float, x: numpy.ndarray[object[m, 1]], t: numpy.ndarray[object[m, 1]]) -> List[pydrake.solvers.BindingTConstraintU]: ...
    def AddPointInSetConstraints(self, prog: pydrake.solvers.MathematicalProgram, vars: numpy.ndarray[object[m, 1]]) -> Tuple[numpy.ndarray[object[m, 1]], List[pydrake.solvers.BindingTConstraintU]]: ...
    def CalcVolume(self) -> float: ...
    def CalcVolumeViaSampling(self, generator: pydrake.common.RandomGenerator, desired_rel_accuracy: float = ..., max_num_samples: int = ...) -> SampledVolume: ...
    def Clone(self) -> ConvexSet: ...
    def IntersectsWith(self, other: ConvexSet) -> bool: ...
    def IsBounded(self) -> bool: ...
    def IsEmpty(self) -> bool: ...
    def MaybeGetFeasiblePoint(self) -> Optional[numpy.ndarray[numpy.float64[m, 1]]]: ...
    def MaybeGetPoint(self) -> Optional[numpy.ndarray[numpy.float64[m, 1]]]: ...
    def PointInSet(self, x: numpy.ndarray[numpy.float64[m, 1]], tol: float = ...) -> bool: ...
    def ToShapeWithPose(self) -> Tuple[pydrake.geometry.Shape, pydrake.math.RigidTransform]: ...
    @overload
    def ambient_dimension(self) -> int: ...
    @overload
    def ambient_dimension(self) -> Any: ...

class CspaceFreePolytope(CspaceFreePolytopeBase):
    class BilinearAlternationOptions:
        convergence_tol: float
        ellipsoid_scaling: float
        find_polytope_options: CspaceFreePolytope.FindPolytopeGivenLagrangianOptions
        max_iter: int
        def __init__(self) -> None: ...
        @property
        def find_lagrangian_options(self) -> CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions: ...

    class BinarySearchOptions:
        convergence_tol: float
        max_iter: int
        scale_max: float
        scale_min: float
        def __init__(self) -> None: ...
        @property
        def find_lagrangian_options(self) -> CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions: ...

    class EllipsoidMarginCost:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        _pybind11_del_orig: ClassVar[None] = ...
        kGeometricMean: ClassVar[CspaceFreePolytope.EllipsoidMarginCost] = ...
        kSum: ClassVar[CspaceFreePolytope.EllipsoidMarginCost] = ...
        def __init__(self, value: int) -> None: ...
        def __del__(self, *args, **kwargs) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class FindPolytopeGivenLagrangianOptions:
        backoff_scale: Optional[float]
        ellipsoid_margin_cost: CspaceFreePolytope.EllipsoidMarginCost
        ellipsoid_margin_epsilon: float
        s_inner_pts: Optional[numpy.ndarray[numpy.float64[m, n]]]
        search_s_bounds_lagrangians: bool
        solver_id: pydrake.solvers.SolverId
        solver_options: Optional[pydrake.solvers.SolverOptions]
        def __init__(self) -> None: ...

    class FindSeparationCertificateGivenPolytopeOptions(FindSeparationCertificateOptions):
        ignore_redundant_C: bool
        def __init__(self) -> None: ...

    class SearchResult:
        def __init__(self) -> None: ...
        def C(self) -> numpy.ndarray[numpy.float64[m, n]]: ...
        def a(self) -> Dict[int, numpy.ndarray[object[3, 1]]]: ...
        def b(self) -> Dict[int, pydrake.symbolic.Polynomial]: ...
        def certified_polytope(self) -> HPolyhedron: ...
        def d(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
        def num_iter(self) -> int: ...

    class SeparatingPlaneLagrangians:
        def __init__(self, C_rows: int, s_size: int) -> None: ...
        def GetSolution(self, result: pydrake.solvers.MathematicalProgramResult) -> CspaceFreePolytope.SeparatingPlaneLagrangians: ...
        def polytope(self) -> numpy.ndarray[object[m, 1]]: ...
        def s_lower(self) -> numpy.ndarray[object[m, 1]]: ...
        def s_upper(self) -> numpy.ndarray[object[m, 1]]: ...

    class SeparationCertificate:
        negative_side_rational_lagrangians: List[CspaceFreePolytope.SeparatingPlaneLagrangians]
        positive_side_rational_lagrangians: List[CspaceFreePolytope.SeparatingPlaneLagrangians]
        def __init__(self, *args, **kwargs) -> None: ...
        def GetSolution(self, plane_index: int, a: numpy.ndarray[object[3, 1]], b: pydrake.symbolic.Polynomial, plane_decision_vars: numpy.ndarray[object[m, 1]], result: pydrake.solvers.MathematicalProgramResult) -> CspaceFreePolytope.SeparationCertificateResult: ...

    class SeparationCertificateProgram(SeparationCertificateProgramBase):
        def __init__(self) -> None: ...
        @property
        def certificate(self) -> CspaceFreePolytope.SeparationCertificate: ...
        @property
        def plane_index(self) -> int: ...

    class SeparationCertificateResult:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def a(self) -> numpy.ndarray[object[3, 1]]: ...
        @property
        def b(self) -> pydrake.symbolic.Polynomial: ...
        @property
        def negative_side_rational_lagrangians(self) -> List[CspaceFreePolytope.SeparatingPlaneLagrangians]: ...
        @property
        def plane_decision_var_vals(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
        @property
        def plane_index(self) -> int: ...
        @property
        def positive_side_rational_lagrangians(self) -> List[CspaceFreePolytope.SeparatingPlaneLagrangians]: ...
        @property
        def result(self) -> pydrake.solvers.MathematicalProgramResult: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def BinarySearch(self, *args, **kwargs): ...
    def FindSeparationCertificateGivenPolytope(self, *args, **kwargs): ...
    def MakeIsGeometrySeparableProgram(self, *args, **kwargs): ...
    def SearchWithBilinearAlternation(self, *args, **kwargs): ...
    def SolveSeparationCertificateProgram(self, *args, **kwargs): ...

class CspaceFreePolytopeBase:
    class Options:
        _pybind11_del_orig: ClassVar[None] = ...
        with_cross_y: bool
        def __init__(self) -> None: ...
        def __del__(self, *args, **kwargs) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def map_geometries_to_separating_planes(self) -> Dict[Tuple[pydrake.geometry.GeometryId], int]: ...
    def separating_planes(self) -> List[CSpaceSeparatingPlane_TVariableU]: ...
    def y_slack(self) -> numpy.ndarray[object[3, 1]]: ...

class FindSeparationCertificateOptions:
    num_threads: int
    parallelism: pydrake.common.Parallelism
    solver_id: pydrake.solvers.SolverId
    solver_options: Optional[pydrake.solvers.SolverOptions]
    terminate_at_failure: bool
    verbose: bool
    def __init__(self) -> None: ...

class GraphOfConvexSets:
    class Edge:
        def __init__(self, *args, **kwargs) -> None: ...
        @overload
        def AddConstraint(self, f: pydrake.symbolic.Formula) -> pydrake.solvers.BindingTConstraintU: ...
        @overload
        def AddConstraint(self, binding: pydrake.solvers.BindingTConstraintU) -> pydrake.solvers.BindingTConstraintU: ...
        @overload
        def AddCost(self, e: pydrake.symbolic.Expression) -> Tuple[pydrake.symbolic.Variable, pydrake.solvers.BindingTCostU]: ...
        @overload
        def AddCost(self, binding: pydrake.solvers.BindingTCostU) -> Tuple[pydrake.symbolic.Variable, pydrake.solvers.BindingTCostU]: ...
        def AddPhiConstraint(self, phi_value: bool) -> None: ...
        def ClearPhiConstraints(self) -> None: ...
        def GetConstraints(self) -> List[pydrake.solvers.BindingTConstraintU]: ...
        def GetCosts(self) -> List[pydrake.solvers.BindingTCostU]: ...
        def GetSolutionCost(self, result: pydrake.solvers.MathematicalProgramResult) -> float: ...
        def GetSolutionPhiXu(self, result: pydrake.solvers.MathematicalProgramResult) -> numpy.ndarray[numpy.float64[m, 1]]: ...
        def GetSolutionPhiXv(self, result: pydrake.solvers.MathematicalProgramResult) -> numpy.ndarray[numpy.float64[m, 1]]: ...
        def id(self) -> GraphOfConvexSets.EdgeId: ...
        def name(self) -> str: ...
        @overload
        def phi(self) -> pydrake.symbolic.Variable: ...
        @overload
        def phi(self) -> Any: ...
        def u(self) -> GraphOfConvexSets.Vertex: ...
        def v(self) -> GraphOfConvexSets.Vertex: ...
        @overload
        def xu(self) -> numpy.ndarray[object[m, 1]]: ...
        @overload
        def xu(self) -> Any: ...
        @overload
        def xv(self) -> numpy.ndarray[object[m, 1]]: ...
        @overload
        def xv(self) -> Any: ...

    class EdgeId:
        def __init__(self, *args, **kwargs) -> None: ...
        @classmethod
        def get_new_id(cls) -> GraphOfConvexSets.EdgeId: ...
        def get_value(self) -> int: ...
        def is_valid(self) -> bool: ...
        def __eq__(self, arg0: GraphOfConvexSets.EdgeId) -> bool: ...
        def __hash__(self) -> int: ...
        def __lt__(self, arg0: GraphOfConvexSets.EdgeId) -> bool: ...
        def __ne__(self, arg0: GraphOfConvexSets.EdgeId) -> bool: ...

    class Vertex:
        def __init__(self, *args, **kwargs) -> None: ...
        @overload
        def AddConstraint(self, f: pydrake.symbolic.Formula) -> pydrake.solvers.BindingTConstraintU: ...
        @overload
        def AddConstraint(self, binding: pydrake.solvers.BindingTConstraintU) -> pydrake.solvers.BindingTConstraintU: ...
        @overload
        def AddCost(self, e: pydrake.symbolic.Expression) -> Tuple[pydrake.symbolic.Variable, pydrake.solvers.BindingTCostU]: ...
        @overload
        def AddCost(self, binding: pydrake.solvers.BindingTCostU) -> Tuple[pydrake.symbolic.Variable, pydrake.solvers.BindingTCostU]: ...
        def GetConstraints(self) -> List[pydrake.solvers.BindingTConstraintU]: ...
        def GetCosts(self) -> List[pydrake.solvers.BindingTCostU]: ...
        def GetSolution(self, result: pydrake.solvers.MathematicalProgramResult) -> numpy.ndarray[numpy.float64[m, 1]]: ...
        def GetSolutionCost(self, result: pydrake.solvers.MathematicalProgramResult) -> float: ...
        def ambient_dimension(self) -> int: ...
        def id(self) -> GraphOfConvexSets.VertexId: ...
        def incoming_edges(self, *args, **kwargs): ...
        def name(self) -> str: ...
        def outgoing_edges(self, *args, **kwargs): ...
        def set(self) -> ConvexSet: ...
        def x(self) -> numpy.ndarray[object[m, 1]]: ...

    class VertexId:
        def __init__(self, *args, **kwargs) -> None: ...
        @classmethod
        def get_new_id(cls) -> GraphOfConvexSets.VertexId: ...
        def get_value(self) -> int: ...
        def is_valid(self) -> bool: ...
        def __eq__(self, arg0: GraphOfConvexSets.VertexId) -> bool: ...
        def __hash__(self) -> int: ...
        def __lt__(self, arg0: GraphOfConvexSets.VertexId) -> bool: ...
        def __ne__(self, arg0: GraphOfConvexSets.VertexId) -> bool: ...
    def __init__(self) -> None: ...
    def AddEdge(self, u: GraphOfConvexSets.Vertex, v: GraphOfConvexSets.Vertex, name: str = ...) -> GraphOfConvexSets.Edge: ...
    def AddVertex(self, set: ConvexSet, name: str = ...) -> GraphOfConvexSets.Vertex: ...
    def ClearAllPhiConstraints(self) -> None: ...
    def Edges(self) -> List[GraphOfConvexSets.Edge]: ...
    def GetGraphvizString(self, result: Optional[pydrake.solvers.MathematicalProgramResult] = ..., show_slacks: bool = ..., precision: int = ..., scientific: bool = ...) -> str: ...
    def GetSolutionPath(self, source: GraphOfConvexSets.Vertex, target: GraphOfConvexSets.Vertex, result: pydrake.solvers.MathematicalProgramResult, tolerance: float = ...) -> List[GraphOfConvexSets.Edge]: ...
    def RemoveEdge(self, edge: GraphOfConvexSets.Edge) -> None: ...
    def RemoveVertex(self, vertex: GraphOfConvexSets.Vertex) -> None: ...
    def SolveConvexRestriction(self, active_edges: List[GraphOfConvexSets.Edge], options: GraphOfConvexSetsOptions = ...) -> pydrake.solvers.MathematicalProgramResult: ...
    def SolveShortestPath(self, source: GraphOfConvexSets.Vertex, target: GraphOfConvexSets.Vertex, options: GraphOfConvexSetsOptions = ...) -> pydrake.solvers.MathematicalProgramResult: ...
    def Vertices(self) -> List[GraphOfConvexSets.Vertex]: ...

class GraphOfConvexSetsOptions:
    _pybind11_del_orig: ClassVar[None] = ...
    convex_relaxation: Optional[bool]
    flow_tolerance: float
    max_rounded_paths: Optional[int]
    max_rounding_trials: int
    preprocessing: Optional[bool]
    rounding_seed: int
    rounding_solver_options: Optional[pydrake.solvers.SolverOptions]
    solver: pydrake.solvers.SolverInterface
    solver_options: pydrake.solvers.SolverOptions
    def __init__(self) -> None: ...
    def __del__(self, *args, **kwargs) -> None: ...

class HPolyhedron(ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    @overload
    def __init__(self, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = ...) -> None: ...
    @overload
    def __init__(self, prog: pydrake.solvers.MathematicalProgram) -> None: ...
    def A(self) -> numpy.ndarray[numpy.float64[m, n]]: ...
    def CartesianPower(self, n: int) -> HPolyhedron: ...
    def CartesianProduct(self, other: HPolyhedron) -> HPolyhedron: ...
    def ChebyshevCenter(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def ContainedIn(self, other: HPolyhedron, tol: float = ...) -> bool: ...
    def FindRedundant(self, tol: float = ...) -> Set[int]: ...
    def Intersection(self, other: HPolyhedron, check_for_redundancy: bool = ..., tol: float = ...) -> HPolyhedron: ...
    @classmethod
    def MakeBox(cls, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -> HPolyhedron: ...
    @classmethod
    def MakeL1Ball(cls, dim: int) -> HPolyhedron: ...
    @classmethod
    def MakeUnitBox(cls, dim: int) -> HPolyhedron: ...
    def MaximumVolumeInscribedAffineTransformation(self, circumbody: HPolyhedron) -> HPolyhedron: ...
    def MaximumVolumeInscribedEllipsoid(self) -> Hyperellipsoid: ...
    def PontryaginDifference(self, other: HPolyhedron) -> HPolyhedron: ...
    def ReduceInequalities(self, tol: float = ...) -> HPolyhedron: ...
    def Scale(self, scale: float, center: Optional[numpy.ndarray[numpy.float64[m, 1]]] = ...) -> HPolyhedron: ...
    def SimplifyByIncrementalFaceTranslation(self, min_volume_ratio: float = ..., do_affine_transformation: bool = ..., max_iterations: int = ..., points_to_contain: numpy.ndarray[numpy.float64[m, n]] = ..., intersecting_polytopes: List[HPolyhedron] = ..., keep_whole_intersection: bool = ..., intersection_padding: float = ..., random_seed: int = ...) -> HPolyhedron: ...
    @overload
    def UniformSample(self, generator: pydrake.common.RandomGenerator, previous_sample: numpy.ndarray[numpy.float64[m, 1]], mixing_steps: int = ...) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    @overload
    def UniformSample(self, generator: pydrake.common.RandomGenerator, mixing_steps: int = ...) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def b(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...

class Hyperellipsoid(ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], center: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    @overload
    def __init__(self, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = ...) -> None: ...
    @overload
    def __init__(self, ellipsoid: AffineBall) -> None: ...
    def A(self) -> numpy.ndarray[numpy.float64[m, n]]: ...
    @classmethod
    def MakeAxisAligned(cls, radius: numpy.ndarray[numpy.float64[m, 1]], center: numpy.ndarray[numpy.float64[m, 1]]) -> Hyperellipsoid: ...
    @classmethod
    def MakeHypersphere(cls, radius: float, center: numpy.ndarray[numpy.float64[m, 1]]) -> Hyperellipsoid: ...
    @classmethod
    def MakeUnitBall(cls, dim: int) -> Hyperellipsoid: ...
    def MinimumUniformScalingToTouch(self, other: ConvexSet) -> Tuple[float, numpy.ndarray[numpy.float64[m, 1]]]: ...
    @classmethod
    def MinimumVolumeCircumscribedEllipsoid(cls, points: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], rank_tol: float = ...) -> Hyperellipsoid: ...
    def center(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...

class Hyperrectangle(ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def Center(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def MakeHPolyhedron(self) -> HPolyhedron: ...
    @classmethod
    def MaybeCalcAxisAlignedBoundingBox(cls, set: ConvexSet) -> Optional[Hyperrectangle]: ...
    def MaybeGetIntersection(self, arg0: Hyperrectangle) -> Optional[Hyperrectangle]: ...
    def UniformSample(self, generator: pydrake.common.RandomGenerator) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def lb(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def ub(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...

class Intersection(ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, sets: List[ConvexSet]) -> None: ...
    @overload
    def __init__(self, setA: ConvexSet, setB: ConvexSet) -> None: ...
    def element(self, index: int) -> ConvexSet: ...
    def num_elements(self) -> int: ...

class IrisOptions:
    _pybind11_del_orig: ClassVar[None] = ...
    bounding_region: Optional[HPolyhedron]
    configuration_obstacles: object
    configuration_space_margin: float
    iteration_limit: int
    mixing_steps: int
    num_additional_constraint_infeasible_samples: int
    num_collision_infeasible_samples: int
    prog_with_additional_constraints: pydrake.solvers.MathematicalProgram
    random_seed: int
    relative_termination_threshold: float
    require_sample_point_is_contained: bool
    solver_options: Optional[pydrake.solvers.SolverOptions]
    starting_ellipse: Optional[Hyperellipsoid]
    termination_threshold: float
    def __init__(self, **kwargs) -> None: ...
    def __del__(self, *args, **kwargs) -> None: ...

class MinkowskiSum(ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, sets: List[ConvexSet]) -> None: ...
    @overload
    def __init__(self, setA: ConvexSet, setB: ConvexSet) -> None: ...
    @overload
    def __init__(self, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = ...) -> None: ...
    def num_terms(self) -> int: ...
    def term(self, index: int) -> ConvexSet: ...

class PlaneSide:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kNegative: ClassVar[PlaneSide] = ...
    kPositive: ClassVar[PlaneSide] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Point(ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    @overload
    def __init__(self, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = ..., maximum_allowable_radius: float = ...) -> None: ...
    def set_x(self, x: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def x(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...

class SampledVolume:
    num_samples: int
    rel_accuracy: float
    volume: float
    def __init__(self, *args, **kwargs) -> None: ...

class SeparatingPlaneOrder:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kAffine: ClassVar[SeparatingPlaneOrder] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SeparationCertificateProgramBase:
    def __init__(self, *args, **kwargs) -> None: ...
    def prog(self) -> pydrake.solvers.MathematicalProgram: ...
    @property
    def plane_index(self) -> int: ...

class SeparationCertificateResultBase:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def a(self) -> numpy.ndarray[object[3, 1]]: ...
    @property
    def b(self) -> pydrake.symbolic.Polynomial: ...
    @property
    def plane_decision_var_vals(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    @property
    def result(self) -> pydrake.solvers.MathematicalProgramResult: ...

class Spectrahedron(ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, prog: pydrake.solvers.MathematicalProgram) -> None: ...

class VPolytope(ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, vertices: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, H: HPolyhedron) -> None: ...
    @overload
    def __init__(self, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = ...) -> None: ...
    def GetMinimalRepresentation(self) -> VPolytope: ...
    @classmethod
    def MakeBox(cls, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -> VPolytope: ...
    @classmethod
    def MakeUnitBox(cls, dim: int) -> VPolytope: ...
    def WriteObj(self, filename: os.PathLike) -> None: ...
    def vertices(self) -> numpy.ndarray[numpy.float64[m, n]]: ...

class _TemporaryName_N5drake8geometry12optimization21CSpaceSeparatingPlaneINS_8symbolic8VariableEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __copy__(self) -> CSpaceSeparatingPlane_TVariableU: ...
    def __deepcopy__(self, arg0: dict) -> CSpaceSeparatingPlane_TVariableU: ...
    @property
    def a(self) -> numpy.ndarray[object[3, 1]]: ...
    @property
    def b(self) -> pydrake.symbolic.Polynomial: ...
    @property
    def decision_variables(self) -> numpy.ndarray[object[m, 1]]: ...
    @property
    def expressed_body(self): ...
    @property
    def negative_side_geometry(self) -> CIrisCollisionGeometry: ...
    @property
    def plane_degree(self) -> int: ...
    @property
    def positive_side_geometry(self) -> CIrisCollisionGeometry: ...

@overload
def CalcPairwiseIntersections(convex_sets_A: List[ConvexSet], convex_sets_B: List[ConvexSet], continuous_revolute_joints: List[int]) -> List[Tuple[int, int, numpy.ndarray[numpy.float64[m, 1]]]]: ...
@overload
def CalcPairwiseIntersections(convex_sets: List[ConvexSet], continuous_revolute_joints: List[int]) -> List[Tuple[int, int, numpy.ndarray[numpy.float64[m, 1]]]]: ...
def CheckIfSatisfiesConvexityRadius(convex_set: ConvexSet, continuous_revolute_joints: List[int]) -> bool: ...
def Iris(obstacles: List[ConvexSet], sample: numpy.ndarray[numpy.float64[m, 1]], domain: HPolyhedron, options: IrisOptions = ...) -> HPolyhedron: ...
def IrisInConfigurationSpace(*args, **kwargs): ...
def LoadIrisRegionsYamlFile(filename: os.PathLike, child_name: Optional[str] = ...) -> Dict[str, HPolyhedron]: ...
def MakeIrisObstacles(query_object: pydrake.geometry.QueryObject, reference_frame: Optional[pydrake.geometry.FrameId] = ...) -> List[ConvexSet]: ...
@overload
def PartitionConvexSet(convex_set: ConvexSet, continuous_revolute_joints: List[int], epsilon: float = ...) -> List[ConvexSet]: ...
@overload
def PartitionConvexSet(convex_sets: List[ConvexSet], continuous_revolute_joints: List[int], epsilon: float = ...) -> List[ConvexSet]: ...
def SaveIrisRegionsYamlFile(filename: os.PathLike, regions: Dict[str, HPolyhedron], child_name: Optional[str] = ...) -> None: ...
