import flags
import numpy
import os
import pydrake.autodiffutils
import pydrake.lcm
import pydrake.math
import pydrake.symbolic
import pydrake.systems.framework
from . import all as all, optimization as optimization
from _typeshed import Incomplete
from pydrake.common import FindResourceOrThrow as FindResourceOrThrow
from pydrake.common.cpp_template import ContactSurface_ as ContactSurface_, DrakeVisualizer_ as DrakeVisualizer_, FramePoseVector_ as FramePoseVector_, MeshcatPointCloudVisualizer_ as MeshcatPointCloudVisualizer_, MeshcatVisualizer_ as MeshcatVisualizer_, PenetrationAsPointPair_ as PenetrationAsPointPair_, PolygonSurfaceMeshFieldLinear_ as PolygonSurfaceMeshFieldLinear_, PolygonSurfaceMesh_ as PolygonSurfaceMesh_, QueryObject_ as QueryObject_, SceneGraphInspector_ as SceneGraphInspector_, SceneGraph_ as SceneGraph_, SignedDistancePair_ as SignedDistancePair_, SignedDistanceToPoint_ as SignedDistanceToPoint_, TriangleSurfaceMeshFieldLinear_ as TriangleSurfaceMeshFieldLinear_, TriangleSurfaceMesh_ as TriangleSurfaceMesh_, VolumeMesh_ as VolumeMesh_
from typing import Any, Callable, ClassVar, Dict, List, Optional, Tuple, Union, overload

StartMeshcat: Callable

class Box(Shape):
    @overload
    def __init__(self, width: float, depth: float, height: float) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
    def depth(self) -> float: ...
    def height(self) -> float: ...
    def size(self) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def width(self) -> float: ...

class Capsule(Shape):
    @overload
    def __init__(self, radius: float, length: float) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[2, 1]]) -> None: ...
    def length(self) -> float: ...
    def radius(self) -> float: ...

class ClippingRange:
    @overload
    def __init__(self, other: ClippingRange) -> None: ...
    @overload
    def __init__(self, near: float, far: float) -> None: ...
    def far(self) -> float: ...
    def near(self) -> float: ...

class CollisionFilterDeclaration:
    def __init__(self) -> None: ...
    def AllowBetween(self, *args, **kwargs): ...
    def AllowWithin(self, *args, **kwargs): ...
    def ExcludeBetween(self, *args, **kwargs): ...
    def ExcludeWithin(self, *args, **kwargs): ...

class CollisionFilterManager:
    def __init__(self, *args, **kwargs) -> None: ...
    def Apply(self, declaration: CollisionFilterDeclaration) -> None: ...
    def ApplyTransient(self, *args, **kwargs): ...
    def IsActive(self, *args, **kwargs): ...
    def RemoveDeclaration(self, *args, **kwargs): ...
    def has_transient_history(self) -> bool: ...

class ColorRenderCamera:
    def __init__(self, other: ColorRenderCamera) -> None: ...
    def core(self, *args, **kwargs): ...
    def show_window(self) -> bool: ...
    def __copy__(self) -> ColorRenderCamera: ...
    def __deepcopy__(self, arg0: dict) -> ColorRenderCamera: ...

class ContactSurface:
    def __init__(self, *args, **kwargs) -> None: ...
    def Equal(self, surface: ContactSurface) -> bool: ...
    def EvaluateGradE_M_W(self, index: int) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def EvaluateGradE_N_W(self, index: int) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def HasGradE_M(self) -> bool: ...
    def HasGradE_N(self) -> bool: ...
    def area(self, face_index: int) -> float: ...
    @overload
    def centroid(self, face_index: int) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    @overload
    def centroid(self) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def face_normal(self, face_index: int) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def id_M(self) -> GeometryId: ...
    def id_N(self) -> GeometryId: ...
    def is_triangle(self) -> bool: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def poly_e_MN(self) -> PolygonSurfaceMeshFieldLinear: ...
    def poly_mesh_W(self) -> PolygonSurfaceMesh: ...
    def representation(self) -> HydroelasticContactRepresentation: ...
    def total_area(self) -> float: ...
    def tri_e_MN(self) -> TriangleSurfaceMeshFieldLinear: ...
    def tri_mesh_W(self) -> TriangleSurfaceMesh: ...
    def __copy__(self) -> ContactSurface: ...
    def __deepcopy__(self, arg0: dict) -> ContactSurface: ...

class ContactSurface_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Equal(self, surface: ContactSurface_TAutoDiffXdU) -> bool: ...
    def EvaluateGradE_M_W(self, index: int) -> numpy.ndarray[object[3, 1]]: ...
    def EvaluateGradE_N_W(self, index: int) -> numpy.ndarray[object[3, 1]]: ...
    def HasGradE_M(self) -> bool: ...
    def HasGradE_N(self) -> bool: ...
    def area(self, face_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def centroid(self, face_index: int) -> numpy.ndarray[object[3, 1]]: ...
    @overload
    def centroid(self) -> numpy.ndarray[object[3, 1]]: ...
    def face_normal(self, face_index: int) -> numpy.ndarray[object[3, 1]]: ...
    def id_M(self) -> GeometryId: ...
    def id_N(self) -> GeometryId: ...
    def is_triangle(self) -> bool: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def poly_e_MN(self) -> PolygonSurfaceMeshFieldLinear_TAutoDiffXdcAutoDiffXdU: ...
    def poly_mesh_W(self) -> PolygonSurfaceMesh_TAutoDiffXdU: ...
    def representation(self) -> HydroelasticContactRepresentation: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def tri_e_MN(self) -> TriangleSurfaceMeshFieldLinear_TAutoDiffXdcAutoDiffXdU: ...
    def tri_mesh_W(self) -> TriangleSurfaceMesh_TAutoDiffXdU: ...
    def __copy__(self) -> ContactSurface_TAutoDiffXdU: ...
    def __deepcopy__(self, arg0: dict) -> ContactSurface_TAutoDiffXdU: ...

class Convex(Shape):
    def __init__(self, filename: str, scale: float = ...) -> None: ...
    def GetConvexHull(self) -> PolygonSurfaceMesh: ...
    @overload
    def extension(self) -> str: ...
    @overload
    def extension(self) -> Any: ...
    def filename(self) -> str: ...
    def scale(self) -> float: ...

class Cylinder(Shape):
    @overload
    def __init__(self, radius: float, length: float) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[2, 1]]) -> None: ...
    def length(self) -> float: ...
    def radius(self) -> float: ...

class DepthRange:
    @overload
    def __init__(self, other: DepthRange) -> None: ...
    @overload
    def __init__(self, min_in: float, min_out: float) -> None: ...
    def max_depth(self) -> float: ...
    def min_depth(self) -> float: ...
    def __copy__(self) -> DepthRange: ...
    def __deepcopy__(self, arg0: dict) -> DepthRange: ...

class DepthRenderCamera:
    def __init__(self, other: DepthRenderCamera) -> None: ...
    def core(self, *args, **kwargs): ...
    def depth_range(self) -> DepthRange: ...
    def __copy__(self) -> DepthRenderCamera: ...
    def __deepcopy__(self, arg0: dict) -> DepthRenderCamera: ...

class DrakeVisualizer(pydrake.systems.framework.LeafSystem):
    def __init__(self, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> None: ...
    @overload
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder, scene_graph: SceneGraph, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> DrakeVisualizer: ...
    @overload
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder, query_object_port: pydrake.systems.framework.OutputPort, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> DrakeVisualizer: ...
    @classmethod
    def DispatchLoadMessage(cls, scene_graph: SceneGraph, lcm: pydrake.lcm.DrakeLcmInterface, params: DrakeVisualizerParams = ...) -> None: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort: ...

class DrakeVisualizerParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    default_color: Rgba
    publish_period: float
    role: Role
    show_hydroelastic: bool
    use_role_channel_suffix: bool
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> DrakeVisualizerParams: ...
    def __deepcopy__(self, arg0: dict) -> DrakeVisualizerParams: ...
    def __del__(self, *args, **kwargs) -> None: ...

class DrakeVisualizer_𝓣AutoDiffXd𝓤(pydrake.systems.framework.LeafSystem_TAutoDiffXdU):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> None: ...
    @overload
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_TAutoDiffXdU, scene_graph: SceneGraph_TAutoDiffXdU, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> DrakeVisualizer_TAutoDiffXdU: ...
    @overload
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_TAutoDiffXdU, query_object_port: pydrake.systems.framework.OutputPort_TAutoDiffXdU, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> DrakeVisualizer_TAutoDiffXdU: ...
    @classmethod
    def DispatchLoadMessage(cls, scene_graph: SceneGraph_TAutoDiffXdU, lcm: pydrake.lcm.DrakeLcmInterface, params: DrakeVisualizerParams = ...) -> None: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_TAutoDiffXdU: ...

class Ellipsoid(Shape):
    @overload
    def __init__(self, a: float, b: float, c: float) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
    def a(self) -> float: ...
    def b(self) -> float: ...
    def c(self) -> float: ...

class EnvironmentMap:
    __fields__: ClassVar[tuple] = ...  # read-only
    skybox: bool
    texture: Union[NullTexture, EquirectangularMap]
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> EnvironmentMap: ...
    def __deepcopy__(self, arg0: dict) -> EnvironmentMap: ...

class EquirectangularMap:
    __fields__: ClassVar[tuple] = ...  # read-only
    path: str
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> EquirectangularMap: ...
    def __deepcopy__(self, arg0: dict) -> EquirectangularMap: ...

class FilterId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> FilterId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: FilterId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: FilterId) -> bool: ...
    def __ne__(self, arg0: FilterId) -> bool: ...

class FrameId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> FrameId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: FrameId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: FrameId) -> bool: ...
    def __ne__(self, arg0: FrameId) -> bool: ...

class FramePoseVector:
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform: ...

class FramePoseVector_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_TAutoDiffXdU) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_TAutoDiffXdU: ...

class FramePoseVector_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_TExpressionU) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_TExpressionU: ...

class GeometryFrame:
    def __init__(self, frame_name: str, frame_group_id: int = ...) -> None: ...
    def frame_group(self) -> int: ...
    def id(self, *args, **kwargs): ...
    def name(self) -> str: ...
    def __copy__(self) -> GeometryFrame: ...
    def __deepcopy__(self, arg0: dict) -> GeometryFrame: ...

class GeometryId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> GeometryId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: GeometryId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: GeometryId) -> bool: ...
    def __ne__(self, arg0: GeometryId) -> bool: ...

class GeometryInstance:
    def __init__(self, *args, **kwargs) -> None: ...
    def id(self, *args, **kwargs): ...
    def illustration_properties(self, *args, **kwargs): ...
    def mutable_illustration_properties(self, *args, **kwargs): ...
    def mutable_perception_properties(self, *args, **kwargs): ...
    def mutable_proximity_properties(self, *args, **kwargs): ...
    def name(self) -> str: ...
    def perception_properties(self, *args, **kwargs): ...
    def pose(self) -> pydrake.math.RigidTransform: ...
    def proximity_properties(self, *args, **kwargs): ...
    def set_illustration_properties(self, *args, **kwargs): ...
    def set_name(self, arg0: str) -> None: ...
    def set_perception_properties(self, *args, **kwargs): ...
    def set_pose(self, X_PG: pydrake.math.RigidTransform) -> None: ...
    def set_proximity_properties(self, *args, **kwargs): ...
    def shape(self, *args, **kwargs): ...
    def __copy__(self) -> GeometryInstance: ...
    def __deepcopy__(self, arg0: dict) -> GeometryInstance: ...

class GeometryProperties:
    def __init__(self, *args, **kwargs) -> None: ...
    def AddProperty(self, group_name: str, name: str, value: object) -> None: ...
    def GetGroupNames(self) -> Set[str]: ...
    def GetPropertiesInGroup(self, group_name: str) -> dict: ...
    def GetProperty(self, group_name: str, name: str) -> object: ...
    def GetPropertyOrDefault(self, group_name: str, name: str, default_value: object) -> object: ...
    def HasGroup(self, group_name: str) -> bool: ...
    def HasProperty(self, group_name: str, name: str) -> bool: ...
    def RemoveProperty(self, group_name: str, name: str) -> bool: ...
    def UpdateProperty(self, group_name: str, name: str, value: object) -> None: ...
    @classmethod
    def default_group_name(cls) -> str: ...
    def num_groups(self) -> int: ...

class GeometrySet:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, geometry_ids) -> None: ...
    @overload
    def __init__(self, frame_ids) -> None: ...
    @overload
    def __init__(self, geometry_ids, frame_ids) -> None: ...
    @overload
    def Add(self, geometry_ids) -> None: ...
    @overload
    def Add(self, frame_ids) -> None: ...
    @overload
    def Add(self, geometry_ids, frame_ids) -> None: ...

class GeometryVersion:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: GeometryVersion) -> None: ...
    def IsSameAs(self, *args, **kwargs): ...
    def __copy__(self) -> GeometryVersion: ...
    def __deepcopy__(self, arg0: dict) -> GeometryVersion: ...

class GltfExtension:
    __fields__: ClassVar[tuple] = ...  # read-only
    warn_unimplemented: bool
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> GltfExtension: ...
    def __deepcopy__(self, arg0: dict) -> GltfExtension: ...

class HalfSpace(Shape):
    def __init__(self) -> None: ...
    @classmethod
    def MakePose(cls, Hz_dir_F: numpy.ndarray[numpy.float64[3, 1]], p_FB: numpy.ndarray[numpy.float64[3, 1]]) -> pydrake.math.RigidTransform: ...

class HydroelasticContactRepresentation:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kPolygon: ClassVar[HydroelasticContactRepresentation] = ...
    kTriangle: ClassVar[HydroelasticContactRepresentation] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class IllustrationProperties(GeometryProperties):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: IllustrationProperties) -> None: ...
    def __copy__(self) -> IllustrationProperties: ...
    def __deepcopy__(self, arg0: dict) -> IllustrationProperties: ...

class LightParameter:
    __fields__: ClassVar[tuple] = ...  # read-only
    attenuation_values: numpy.ndarray[numpy.float64[3, 1]]
    color: Rgba
    cone_angle: float
    direction: numpy.ndarray[numpy.float64[3, 1]]
    frame: str
    intensity: float
    position: numpy.ndarray[numpy.float64[3, 1]]
    type: str
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> LightParameter: ...
    def __deepcopy__(self, arg0: dict) -> LightParameter: ...

class Mesh(Shape):
    def __init__(self, filename: str, scale: float = ...) -> None: ...
    def GetConvexHull(self) -> PolygonSurfaceMesh: ...
    @overload
    def extension(self) -> str: ...
    @overload
    def extension(self) -> Any: ...
    def filename(self) -> str: ...
    def scale(self) -> float: ...

class Meshcat:
    class Gamepad:
        __fields__: ClassVar[tuple] = ...  # read-only
        axes: Incomplete
        button_values: List[float]
        index: Optional[int]
        def __init__(self, **kwargs) -> None: ...
        def __copy__(self) -> Meshcat.Gamepad: ...
        def __deepcopy__(self, arg0: dict) -> Meshcat.Gamepad: ...

    class OrthographicCamera:
        __fields__: ClassVar[tuple] = ...  # read-only
        bottom: float
        far: float
        left: float
        near: float
        right: float
        top: float
        zoom: float
        def __init__(self, **kwargs) -> None: ...
        def __copy__(self) -> Meshcat.OrthographicCamera: ...
        def __deepcopy__(self, arg0: dict) -> Meshcat.OrthographicCamera: ...

    class PerspectiveCamera:
        __fields__: ClassVar[tuple] = ...  # read-only
        aspect: float
        far: float
        fov: float
        near: float
        zoom: float
        def __init__(self, **kwargs) -> None: ...
        def __copy__(self) -> Meshcat.PerspectiveCamera: ...
        def __deepcopy__(self, arg0: dict) -> Meshcat.PerspectiveCamera: ...

    class SideOfFaceToRender:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        _pybind11_del_orig: ClassVar[None] = ...
        kBackSide: ClassVar[Meshcat.SideOfFaceToRender] = ...
        kDoubleSide: ClassVar[Meshcat.SideOfFaceToRender] = ...
        kFrontSide: ClassVar[Meshcat.SideOfFaceToRender] = ...
        def __init__(self, value: int) -> None: ...
        def __del__(self, *args, **kwargs) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    @overload
    def __init__(self, port: Optional[int] = ...) -> None: ...
    @overload
    def __init__(self, params: MeshcatParams) -> None: ...
    def AddButton(self, name: str, keycode: str = ...) -> None: ...
    def AddSlider(self, name: str, min: float, max: float, step: float, value: float, decrement_keycode: str = ..., increment_keycode: str = ...) -> None: ...
    def Delete(self, path: str = ...) -> None: ...
    def DeleteAddedControls(self) -> None: ...
    def DeleteButton(self, name: str) -> None: ...
    def DeleteRecording(self) -> None: ...
    def DeleteSlider(self, name: str) -> None: ...
    def Flush(self) -> None: ...
    def GetButtonClicks(self, name: str) -> int: ...
    def GetGamepad(self, *args, **kwargs): ...
    def GetNumActiveConnections(self) -> int: ...
    def GetRealtimeRate(self) -> float: ...
    def GetSliderNames(self) -> List[str]: ...
    def GetSliderValue(self, name: str) -> float: ...
    def GetTrackedCameraPose(self) -> Optional[pydrake.math.RigidTransform]: ...
    def HasPath(self, path: str) -> bool: ...
    def PlotSurface(self, path: str, X: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], Y: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], Z: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], rgba: Rgba = ..., wireframe: bool = ..., wireframe_line_width: float = ...) -> None: ...
    def PublishRecording(self) -> None: ...
    def ResetRenderMode(self) -> None: ...
    def Set2dRenderMode(self, X_WC: pydrake.math.RigidTransform = ..., xmin: float = ..., xmax: float = ..., ymin: float = ..., ymax: float = ...) -> None: ...
    def SetAnimation(self) -> Any: ...
    def SetCamera(self, *args, **kwargs): ...
    def SetCameraPose(self, camera_in_world: numpy.ndarray[numpy.float64[3, 1]], target_in_world: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
    def SetCameraTarget(self, target_in_world: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
    def SetEnvironmentMap(self, image_path: os.PathLike) -> None: ...
    def SetLine(self, path: str, vertices: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], line_width: float = ..., rgba: Rgba = ...) -> None: ...
    def SetLineSegments(self, path: str, start: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], end: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], line_width: float = ..., rgba: Rgba = ...) -> None: ...
    @overload
    def SetObject(self, path: str, shape: Shape, rgba: Rgba = ...) -> None: ...
    @overload
    def SetObject(self, path: str, mesh: TriangleSurfaceMesh, rgba: Rgba = ..., wireframe: bool = ..., wireframe_line_width: float = ..., side: Meshcat.SideOfFaceToRender = ...) -> None: ...
    @overload
    def SetProperty(self, path: str, property: str, value: bool, time_in_recording: Optional[float] = ...) -> None: ...
    @overload
    def SetProperty(self, path: str, property: str, value: float, time_in_recording: Optional[float] = ...) -> None: ...
    @overload
    def SetProperty(self, path: str, property: str, value: List[float], time_in_recording: Optional[float] = ...) -> None: ...
    def SetRealtimeRate(self, rate: float) -> None: ...
    def SetSliderValue(self, name: str, value: float) -> None: ...
    @overload
    def SetTransform(self, path: str, X_ParentPath: pydrake.math.RigidTransform, time_in_recording: Optional[float] = ...) -> None: ...
    @overload
    def SetTransform(self, path: str, matrix: numpy.ndarray[numpy.float64[4, 4], flags.f_contiguous]) -> None: ...
    def SetTriangleColorMesh(self, path: str, vertices: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], faces: numpy.ndarray[numpy.int32[3, n], flags.f_contiguous], colors: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], wireframe: bool = ..., wireframe_line_width: float = ..., side: Meshcat.SideOfFaceToRender = ...) -> None: ...
    def SetTriangleMesh(self, path: str, vertices: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], faces: numpy.ndarray[numpy.int32[3, n], flags.f_contiguous], rgba: Rgba = ..., wireframe: bool = ..., wireframe_line_width: float = ..., side: Meshcat.SideOfFaceToRender = ...) -> None: ...
    def StartRecording(self, frames_per_second: float = ..., set_visualizations_while_recording: bool = ...) -> None: ...
    def StaticHtml(self) -> str: ...
    def StopRecording(self) -> None: ...
    def get_mutable_recording(self, *args, **kwargs): ...
    def port(self) -> int: ...
    def web_url(self) -> str: ...
    def ws_url(self) -> str: ...

class MeshcatAnimation:
    class LoopMode:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        _pybind11_del_orig: ClassVar[None] = ...
        kLoopOnce: ClassVar[MeshcatAnimation.LoopMode] = ...
        kLoopPingPong: ClassVar[MeshcatAnimation.LoopMode] = ...
        kLoopRepeat: ClassVar[MeshcatAnimation.LoopMode] = ...
        def __init__(self, value: int) -> None: ...
        def __del__(self, *args, **kwargs) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self, frames_per_second: float = ...) -> None: ...
    @overload
    def SetProperty(self, frame: int, path: str, property: str, value: bool) -> None: ...
    @overload
    def SetProperty(self, frame: int, path: str, property: str, value: float) -> None: ...
    @overload
    def SetProperty(self, frame: int, path: str, property: str, value: List[float]) -> None: ...
    def SetTransform(self, frame: int, path: str, X_ParentPath: pydrake.math.RigidTransform) -> None: ...
    def autoplay(self) -> bool: ...
    def clamp_when_finished(self) -> bool: ...
    def frame(self, time_from_start: float) -> int: ...
    def frames_per_second(self) -> float: ...
    def loop_mode(self, *args, **kwargs): ...
    def repetitions(self) -> int: ...
    def set_autoplay(self, play: bool) -> None: ...
    def set_clamp_when_finished(self, clamp: bool) -> None: ...
    def set_loop_mode(self, *args, **kwargs): ...
    def set_repetitions(self, repetitions: int) -> None: ...

class MeshcatCone(Shape):
    @overload
    def __init__(self, height: float, a: float = ..., b: float = ...) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
    def a(self) -> float: ...
    def b(self) -> float: ...
    def height(self) -> float: ...

class MeshcatParams:
    class PropertyTuple:
        __fields__: ClassVar[tuple] = ...  # read-only
        path: str
        property: str
        value: Union[List[float], str, bool, float]
        def __init__(self, **kwargs) -> None: ...
        def __copy__(self) -> MeshcatParams.PropertyTuple: ...
        def __deepcopy__(self, arg0: dict) -> MeshcatParams.PropertyTuple: ...
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    host: str
    initial_properties: List[MeshcatParams.PropertyTuple]
    port: Optional[int]
    show_stats_plot: bool
    web_url_pattern: str
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> MeshcatParams: ...
    def __deepcopy__(self, arg0: dict) -> MeshcatParams: ...
    def __del__(self, *args, **kwargs) -> None: ...

class MeshcatPointCloudVisualizer(pydrake.systems.framework.LeafSystem):
    def __init__(self, meshcat: Meshcat, path: str, publish_period: float = ...) -> None: ...
    @overload
    def Delete(self) -> None: ...
    @overload
    def Delete(self, path) -> Any: ...
    def cloud_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def pose_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def set_default_rgba(self, arg0: Rgba) -> None: ...
    def set_point_size(self, arg0: float) -> None: ...

class MeshcatPointCloudVisualizer_𝓣AutoDiffXd𝓤(pydrake.systems.framework.LeafSystem_TAutoDiffXdU):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, path: str, publish_period: float = ...) -> None: ...
    @overload
    def Delete(self) -> None: ...
    @overload
    def Delete(self, path) -> Any: ...
    def cloud_input_port(self) -> pydrake.systems.framework.InputPort_TAutoDiffXdU: ...
    def pose_input_port(self) -> pydrake.systems.framework.InputPort_TAutoDiffXdU: ...
    def set_default_rgba(self, arg0: Rgba) -> None: ...
    def set_point_size(self, arg0: float) -> None: ...

class MeshcatVisualizer(pydrake.systems.framework.LeafSystem):
    def __init__(self, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> None: ...
    @overload
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder, scene_graph: SceneGraph, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> MeshcatVisualizer: ...
    @overload
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder, query_object_port: pydrake.systems.framework.OutputPort, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> MeshcatVisualizer: ...
    def Delete(self) -> None: ...
    def DeleteRecording(self) -> None: ...
    def PublishRecording(self) -> None: ...
    def ResetRealtimeRateCalculator(self) -> None: ...
    def StartRecording(self, set_transforms_while_recording: bool = ...) -> MeshcatAnimation: ...
    def StopRecording(self) -> None: ...
    def get_mutable_recording(self) -> MeshcatAnimation: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort: ...

class MeshcatVisualizerParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    default_color: Rgba
    delete_on_initialization_event: bool
    enable_alpha_slider: bool
    include_unspecified_accepting: bool
    initial_alpha_slider_value: float
    prefix: str
    publish_period: float
    role: Role
    show_hydroelastic: bool
    visible_by_default: bool
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> MeshcatVisualizerParams: ...
    def __deepcopy__(self, arg0: dict) -> MeshcatVisualizerParams: ...
    def __del__(self, *args, **kwargs) -> None: ...

class MeshcatVisualizer_𝓣AutoDiffXd𝓤(pydrake.systems.framework.LeafSystem_TAutoDiffXdU):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> None: ...
    @overload
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_TAutoDiffXdU, scene_graph: SceneGraph_TAutoDiffXdU, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> MeshcatVisualizer_TAutoDiffXdU: ...
    @overload
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_TAutoDiffXdU, query_object_port: pydrake.systems.framework.OutputPort_TAutoDiffXdU, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> MeshcatVisualizer_TAutoDiffXdU: ...
    def Delete(self) -> None: ...
    def DeleteRecording(self) -> None: ...
    def PublishRecording(self) -> None: ...
    def ResetRealtimeRateCalculator(self) -> None: ...
    def StartRecording(self, set_transforms_while_recording: bool = ...) -> MeshcatAnimation: ...
    def StopRecording(self) -> None: ...
    def get_mutable_recording(self) -> MeshcatAnimation: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_TAutoDiffXdU: ...

class NullTexture:
    __fields__: ClassVar[tuple] = ...  # read-only
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> NullTexture: ...
    def __deepcopy__(self, arg0: dict) -> NullTexture: ...

class PenetrationAsPointPair:
    depth: float
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[numpy.float64[3, 1]]
    p_WCa: numpy.ndarray[numpy.float64[3, 1]]
    p_WCb: numpy.ndarray[numpy.float64[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class PenetrationAsPointPair_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: pydrake.autodiffutils.AutoDiffXd
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3, 1]]
    p_WCa: numpy.ndarray[object[3, 1]]
    p_WCb: numpy.ndarray[object[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class PenetrationAsPointPair_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: pydrake.symbolic.Expression
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3, 1]]
    p_WCa: numpy.ndarray[object[3, 1]]
    p_WCb: numpy.ndarray[object[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class PerceptionProperties(GeometryProperties):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: PerceptionProperties) -> None: ...
    def __copy__(self) -> PerceptionProperties: ...
    def __deepcopy__(self, arg0: dict) -> PerceptionProperties: ...

class PolygonSurfaceMesh:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, face_data: List[int], vertices: List[numpy.ndarray[numpy.float64[3, 1]]]) -> None: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[numpy.float64[3, 1]], numpy.ndarray[numpy.float64[3, 1]]]: ...
    def Equal(self, mesh: PolygonSurfaceMesh) -> bool: ...
    def area(self, f: int) -> float: ...
    def centroid(self) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def element(self, e: int) -> SurfacePolygon: ...
    def element_centroid(self, e: int) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def face_data(self) -> List[int]: ...
    def face_normal(self, f: int) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def num_elements(self) -> int: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> float: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def __copy__(self) -> PolygonSurfaceMesh: ...
    def __deepcopy__(self, arg0: dict) -> PolygonSurfaceMesh: ...

class PolygonSurfaceMeshFieldLinear:
    def __init__(self, *args, **kwargs) -> None: ...
    def EvaluateAtVertex(self, v: int) -> float: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[numpy.float64[3, 1]]) -> float: ...
    def EvaluateGradient(self, e: int) -> numpy.ndarray[numpy.float64[3, 1]]: ...

class PolygonSurfaceMeshFieldLinear_𝓣AutoDiffXd𝓬AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def EvaluateAtVertex(self, v: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[object[3, 1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateGradient(self, e: int) -> numpy.ndarray[object[3, 1]]: ...

class PolygonSurfaceMesh_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, face_data: List[int], vertices: List[numpy.ndarray[object[3, 1]]]) -> None: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[object[3, 1]], numpy.ndarray[object[3, 1]]]: ...
    def Equal(self, mesh: PolygonSurfaceMesh_TAutoDiffXdU) -> bool: ...
    def area(self, f: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def centroid(self) -> numpy.ndarray[object[3, 1]]: ...
    def element(self, e: int) -> SurfacePolygon: ...
    def element_centroid(self, e: int) -> numpy.ndarray[object[3, 1]]: ...
    def face_data(self) -> List[int]: ...
    def face_normal(self, f: int) -> numpy.ndarray[object[3, 1]]: ...
    def num_elements(self) -> int: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3, 1]]: ...
    def __copy__(self) -> PolygonSurfaceMesh_TAutoDiffXdU: ...
    def __deepcopy__(self, arg0: dict) -> PolygonSurfaceMesh_TAutoDiffXdU: ...

class ProximityProperties(GeometryProperties):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: ProximityProperties) -> None: ...
    def __copy__(self) -> ProximityProperties: ...
    def __deepcopy__(self, arg0: dict) -> ProximityProperties: ...

class QueryObject:
    def __init__(self) -> None: ...
    def ComputeContactSurfaces(self, *args, **kwargs): ...
    def ComputeContactSurfacesWithFallback(self, *args, **kwargs): ...
    def ComputePointPairPenetration(self, *args, **kwargs): ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs): ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs): ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs): ...
    def FindCollisionCandidates(self, *args, **kwargs): ...
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs): ...
    def RenderDepthImage(self, *args, **kwargs): ...
    def RenderLabelImage(self, *args, **kwargs): ...
    def inspector(self) -> SceneGraphInspector: ...

class QueryObject_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputeContactSurfaces(self, *args, **kwargs): ...
    def ComputeContactSurfacesWithFallback(self, *args, **kwargs): ...
    def ComputePointPairPenetration(self, *args, **kwargs): ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs): ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs): ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs): ...
    def FindCollisionCandidates(self, *args, **kwargs): ...
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_TAutoDiffXdU: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_TAutoDiffXdU: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_TAutoDiffXdU: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs): ...
    def RenderDepthImage(self, *args, **kwargs): ...
    def RenderLabelImage(self, *args, **kwargs): ...
    def inspector(self) -> SceneGraphInspector_TAutoDiffXdU: ...

class QueryObject_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputePointPairPenetration(self, *args, **kwargs): ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs): ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs): ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs): ...
    def FindCollisionCandidates(self, *args, **kwargs): ...
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_TExpressionU: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_TExpressionU: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_TExpressionU: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs): ...
    def RenderDepthImage(self, *args, **kwargs): ...
    def RenderLabelImage(self, *args, **kwargs): ...
    def inspector(self) -> SceneGraphInspector_TExpressionU: ...

class RenderCameraCore:
    def __init__(self, other: RenderCameraCore) -> None: ...
    def clipping(self) -> ClippingRange: ...
    def intrinsics(self, *args, **kwargs): ...
    def renderer_name(self) -> str: ...
    def sensor_pose_in_camera_body(self) -> pydrake.math.RigidTransform: ...
    def __copy__(self) -> RenderCameraCore: ...
    def __deepcopy__(self, arg0: dict) -> RenderCameraCore: ...

class RenderEngine:
    def __init__(self) -> None: ...
    def Clone(self) -> RenderEngine: ...
    @classmethod
    def GetColorDFromLabel(cls, *args, **kwargs): ...
    @classmethod
    def GetColorIFromLabel(cls, *args, **kwargs): ...
    def GetRenderLabelOrThrow(self, *args, **kwargs): ...
    @classmethod
    def LabelFromColor(cls, *args, **kwargs): ...
    def RegisterVisual(self, id: GeometryId, shape: Shape, properties: PerceptionProperties, X_WG: pydrake.math.RigidTransform, needs_updates: bool = ...) -> bool: ...
    def RemoveGeometry(self, id: GeometryId) -> bool: ...
    def RenderColorImage(self, *args, **kwargs): ...
    def RenderDepthImage(self, *args, **kwargs): ...
    def RenderLabelImage(self, *args, **kwargs): ...
    def SetDefaultLightPosition(self, X_DL: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
    @classmethod
    def ThrowIfInvalid(cls, *args, **kwargs): ...
    def UpdateViewpoint(self, X_WR: pydrake.math.RigidTransform) -> None: ...
    def default_render_label(self, *args, **kwargs): ...
    def has_geometry(self, id: GeometryId) -> bool: ...

class RenderEngineGlParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    default_clear_color: Rgba
    default_diffuse: Rgba
    lights: List[LightParameter]
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> RenderEngineGlParams: ...
    def __deepcopy__(self, arg0: dict) -> RenderEngineGlParams: ...
    def __del__(self, *args, **kwargs) -> None: ...

class RenderEngineGltfClientParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    base_url: str
    cleanup: bool
    render_endpoint: str
    verbose: bool
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> RenderEngineGltfClientParams: ...
    def __deepcopy__(self, arg0: dict) -> RenderEngineGltfClientParams: ...
    def __del__(self, *args, **kwargs) -> None: ...

class RenderEngineVtkParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    cast_shadows: bool
    default_clear_color: numpy.ndarray[numpy.float64[3, 1]]
    default_diffuse: Optional[numpy.ndarray[numpy.float64[4, 1]]]
    environment_map: Optional[EnvironmentMap]
    exposure: Optional[float]
    gltf_extensions: Dict[str, GltfExtension]
    lights: List[LightParameter]
    shadow_map_size: int
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> RenderEngineVtkParams: ...
    def __deepcopy__(self, arg0: dict) -> RenderEngineVtkParams: ...

class RenderLabel:
    _pybind11_del_orig: ClassVar[None] = ...
    kDoNotRender: ClassVar[RenderLabel] = ...
    kDontCare: ClassVar[RenderLabel] = ...
    kEmpty: ClassVar[RenderLabel] = ...
    kMaxUnreserved: ClassVar[int] = ...
    kUnspecified: ClassVar[RenderLabel] = ...
    def __init__(self, value: int) -> None: ...
    def is_reserved(self) -> bool: ...
    def __del__(self, *args, **kwargs) -> None: ...
    @overload
    def __eq__(self, arg0: RenderLabel) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, arg0: RenderLabel) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...

class Rgba:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    rgba: numpy.ndarray[numpy.float64[4, 1]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, r: float, g: float, b: float, a: float = ...) -> None: ...
    def a(self) -> float: ...
    def b(self) -> float: ...
    def g(self) -> float: ...
    def r(self) -> float: ...
    def scale_rgb(self, scale: float) -> Rgba: ...
    @overload
    def set(self, r: float, g: float, b: float, a: float = ...) -> None: ...
    @overload
    def set(self, rgba: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def update(self, r: Optional[float] = ..., g: Optional[float] = ..., b: Optional[float] = ..., a: Optional[float] = ...) -> None: ...
    def __copy__(self) -> Rgba: ...
    def __deepcopy__(self, arg0: dict) -> Rgba: ...
    def __del__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: Rgba) -> bool: ...
    def __mul__(self, arg0: Rgba) -> Rgba: ...
    def __ne__(self, arg0: Rgba) -> bool: ...

class Role:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kIllustration: ClassVar[Role] = ...
    kPerception: ClassVar[Role] = ...
    kProximity: ClassVar[Role] = ...
    kUnassigned: ClassVar[Role] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RoleAssign:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kNew: ClassVar[RoleAssign] = ...
    kReplace: ClassVar[RoleAssign] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SceneGraph(pydrake.systems.framework.LeafSystem):
    def __init__(self) -> None: ...
    @overload
    def AddRenderer(self, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AddRenderer(self, context: pydrake.systems.framework.Context, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AddRenderer(self) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, PerceptionProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, IllustrationProperties) -> Any: ...
    @overload
    def ChangeShape(self, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self, context: pydrake.systems.framework.Context, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self) -> Any: ...
    @overload
    def GetRendererTypeName(self, name: str) -> str: ...
    @overload
    def GetRendererTypeName(self, context: pydrake.systems.framework.Context, name: str) -> str: ...
    @overload
    def GetRendererTypeName(self) -> Any: ...
    @overload
    def HasRenderer(self, name: str) -> bool: ...
    @overload
    def HasRenderer(self, context: pydrake.systems.framework.Context, name: str) -> bool: ...
    @overload
    def HasRenderer(self) -> Any: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    @overload
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self, context: pydrake.systems.framework.Context, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self) -> Any: ...
    @overload
    def RemoveRenderer(self, name: str) -> None: ...
    @overload
    def RemoveRenderer(self, context: pydrake.systems.framework.Context, name: str) -> None: ...
    @overload
    def RemoveRenderer(self) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, GeometryId, Role) -> Any: ...
    def RenameFrame(self, frame_id: FrameId, name: str) -> None: ...
    def RenameGeometry(self, geometry_id: GeometryId, name: str) -> None: ...
    @overload
    def RendererCount(self) -> int: ...
    @overload
    def RendererCount(self, context: pydrake.systems.framework.Context) -> int: ...
    @overload
    def RendererCount(self) -> Any: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort: ...
    def model_inspector(self) -> SceneGraphInspector: ...
    @classmethod
    def world_frame_id(cls) -> FrameId: ...

class SceneGraphInspector:
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetAllSourceIds(self) -> List[SourceId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId, GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None, TriangleSurfaceMesh, VolumeMesh]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class SceneGraphInspector_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetAllSourceIds(self) -> List[SourceId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId, GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None, TriangleSurfaceMesh, VolumeMesh]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class SceneGraphInspector_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetAllSourceIds(self) -> List[SourceId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId, GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None, TriangleSurfaceMesh, VolumeMesh]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class SceneGraph_𝓣AutoDiffXd𝓤(pydrake.systems.framework.LeafSystem_TAutoDiffXdU):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    @overload
    def AddRenderer(self, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AddRenderer(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AddRenderer(self) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, PerceptionProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, IllustrationProperties) -> Any: ...
    @overload
    def ChangeShape(self, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self) -> Any: ...
    @overload
    def GetRendererTypeName(self, name: str) -> str: ...
    @overload
    def GetRendererTypeName(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, name: str) -> str: ...
    @overload
    def GetRendererTypeName(self) -> Any: ...
    @overload
    def HasRenderer(self, name: str) -> bool: ...
    @overload
    def HasRenderer(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, name: str) -> bool: ...
    @overload
    def HasRenderer(self) -> Any: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    @overload
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self) -> Any: ...
    @overload
    def RemoveRenderer(self, name: str) -> None: ...
    @overload
    def RemoveRenderer(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, name: str) -> None: ...
    @overload
    def RemoveRenderer(self) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, GeometryId, Role) -> Any: ...
    def RenameFrame(self, frame_id: FrameId, name: str) -> None: ...
    def RenameGeometry(self, geometry_id: GeometryId, name: str) -> None: ...
    @overload
    def RendererCount(self) -> int: ...
    @overload
    def RendererCount(self, context: pydrake.systems.framework.Context_TAutoDiffXdU) -> int: ...
    @overload
    def RendererCount(self) -> Any: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_TAutoDiffXdU) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_TAutoDiffXdU: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_TAutoDiffXdU: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_TAutoDiffXdU: ...
    def model_inspector(self) -> SceneGraphInspector_TAutoDiffXdU: ...
    @classmethod
    def world_frame_id(cls) -> FrameId: ...

class SceneGraph_𝓣Expression𝓤(pydrake.systems.framework.LeafSystem_TExpressionU):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    @overload
    def AddRenderer(self, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AddRenderer(self, context: pydrake.systems.framework.Context_TExpressionU, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AddRenderer(self) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, PerceptionProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, IllustrationProperties) -> Any: ...
    @overload
    def ChangeShape(self, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self) -> Any: ...
    @overload
    def GetRendererTypeName(self, name: str) -> str: ...
    @overload
    def GetRendererTypeName(self, context: pydrake.systems.framework.Context_TExpressionU, name: str) -> str: ...
    @overload
    def GetRendererTypeName(self) -> Any: ...
    @overload
    def HasRenderer(self, name: str) -> bool: ...
    @overload
    def HasRenderer(self, context: pydrake.systems.framework.Context_TExpressionU, name: str) -> bool: ...
    @overload
    def HasRenderer(self) -> Any: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    @overload
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self) -> Any: ...
    @overload
    def RemoveRenderer(self, name: str) -> None: ...
    @overload
    def RemoveRenderer(self, context: pydrake.systems.framework.Context_TExpressionU, name: str) -> None: ...
    @overload
    def RemoveRenderer(self) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, GeometryId, Role) -> Any: ...
    def RenameFrame(self, frame_id: FrameId, name: str) -> None: ...
    def RenameGeometry(self, geometry_id: GeometryId, name: str) -> None: ...
    @overload
    def RendererCount(self) -> int: ...
    @overload
    def RendererCount(self, context: pydrake.systems.framework.Context_TExpressionU) -> int: ...
    @overload
    def RendererCount(self) -> Any: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_TExpressionU) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_TExpressionU: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_TExpressionU: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_TExpressionU: ...
    def model_inspector(self) -> SceneGraphInspector_TExpressionU: ...
    @classmethod
    def world_frame_id(cls) -> FrameId: ...

class Shape:
    def __init__(self, *args, **kwargs) -> None: ...
    def Clone(self) -> Shape: ...
    def __copy__(self) -> Shape: ...
    def __deepcopy__(self, arg0: dict) -> Shape: ...

class SignedDistancePair:
    distance: float
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[numpy.float64[3, 1]]
    p_ACa: numpy.ndarray[numpy.float64[3, 1]]
    p_BCb: numpy.ndarray[numpy.float64[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistancePair_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.autodiffutils.AutoDiffXd
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3, 1]]
    p_ACa: numpy.ndarray[object[3, 1]]
    p_BCb: numpy.ndarray[object[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistancePair_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.symbolic.Expression
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3, 1]]
    p_ACa: numpy.ndarray[object[3, 1]]
    p_BCb: numpy.ndarray[object[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistanceToPoint:
    distance: float
    grad_W: numpy.ndarray[numpy.float64[3, 1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[numpy.float64[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistanceToPoint_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.autodiffutils.AutoDiffXd
    grad_W: numpy.ndarray[object[3, 1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[object[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistanceToPoint_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.symbolic.Expression
    grad_W: numpy.ndarray[object[3, 1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[object[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class SourceId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> SourceId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: SourceId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: SourceId) -> bool: ...
    def __ne__(self, arg0: SourceId) -> bool: ...

class Sphere(Shape):
    def __init__(self, radius: float) -> None: ...
    def radius(self) -> float: ...

class SurfacePolygon:
    def __init__(self, *args, **kwargs) -> None: ...
    def num_vertices(self) -> int: ...
    def vertex(self, i: int) -> int: ...

class SurfaceTriangle:
    def __init__(self, v0: int, v1: int, v2: int) -> None: ...
    def num_vertices(self) -> int: ...
    def vertex(self, i: int) -> int: ...
    def __copy__(self) -> SurfaceTriangle: ...
    def __deepcopy__(self, arg0: dict) -> SurfaceTriangle: ...

class TriangleSurfaceMesh:
    def __init__(self, triangles: List[SurfaceTriangle], vertices: List[numpy.ndarray[numpy.float64[3, 1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[numpy.float64[3, 1]], t: int) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[numpy.float64[3, 1]], numpy.ndarray[numpy.float64[3, 1]]]: ...
    def CalcCartesianFromBarycentric(self, element_index: int, b_Q: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def Equal(self, mesh: TriangleSurfaceMesh) -> bool: ...
    def area(self, t: int) -> float: ...
    def centroid(self) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def element(self, e: int) -> SurfaceTriangle: ...
    def element_centroid(self, t: int) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def face_normal(self, t: int) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def num_elements(self) -> int: ...
    def num_triangles(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> float: ...
    def triangles(self) -> List[SurfaceTriangle]: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def vertices(self) -> List[numpy.ndarray[numpy.float64[3, 1]]]: ...

class TriangleSurfaceMeshFieldLinear:
    def __init__(self, *args, **kwargs) -> None: ...
    def Evaluate(self, e: int, b: numpy.ndarray[numpy.float64[3, 1]]) -> float: ...
    def EvaluateAtVertex(self, v: int) -> float: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[numpy.float64[3, 1]]) -> float: ...

class TriangleSurfaceMeshFieldLinear_𝓣AutoDiffXd𝓬AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Evaluate(self, e: int, b: numpy.ndarray[object[3, 1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateAtVertex(self, v: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[object[3, 1]]) -> pydrake.autodiffutils.AutoDiffXd: ...

class TriangleSurfaceMesh_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, triangles: List[SurfaceTriangle], vertices: List[numpy.ndarray[object[3, 1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[object[3, 1]], t: int) -> numpy.ndarray[object[3, 1]]: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[object[3, 1]], numpy.ndarray[object[3, 1]]]: ...
    def CalcCartesianFromBarycentric(self, element_index: int, b_Q: numpy.ndarray[object[3, 1]]) -> numpy.ndarray[object[3, 1]]: ...
    def Equal(self, mesh: TriangleSurfaceMesh_TAutoDiffXdU) -> bool: ...
    def area(self, t: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def centroid(self) -> numpy.ndarray[object[3, 1]]: ...
    def element(self, e: int) -> SurfaceTriangle: ...
    def element_centroid(self, t: int) -> numpy.ndarray[object[3, 1]]: ...
    def face_normal(self, t: int) -> numpy.ndarray[object[3, 1]]: ...
    def num_elements(self) -> int: ...
    def num_triangles(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def triangles(self) -> List[SurfaceTriangle]: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3, 1]]: ...
    def vertices(self) -> List[numpy.ndarray[object[3, 1]]]: ...

class VolumeElement:
    def __init__(self, v0: int, v1: int, v2: int, v3: int) -> None: ...
    def vertex(self, i: int) -> int: ...
    def __copy__(self) -> VolumeElement: ...
    def __deepcopy__(self, arg0: dict) -> VolumeElement: ...

class VolumeMesh:
    def __init__(self, elements: List[VolumeElement], vertices: List[numpy.ndarray[numpy.float64[3, 1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[numpy.float64[3, 1]], e: int) -> numpy.ndarray[numpy.float64[4, 1]]: ...
    def CalcTetrahedronVolume(self, e: int) -> float: ...
    def CalcVolume(self) -> float: ...
    def Equal(self, mesh: VolumeMesh, vertex_tolerance: float = ...) -> bool: ...
    def element(self, e: int) -> VolumeElement: ...
    def num_elements(self) -> int: ...
    def num_vertices(self) -> int: ...
    def tetrahedra(self) -> List[VolumeElement]: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3, 1]]: ...
    def vertices(self) -> List[numpy.ndarray[numpy.float64[3, 1]]]: ...

class VolumeMesh_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, elements: List[VolumeElement], vertices: List[numpy.ndarray[object[3, 1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[object[3, 1]], e: int) -> numpy.ndarray[object[4, 1]]: ...
    def CalcTetrahedronVolume(self, e: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcVolume(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def Equal(self, mesh: VolumeMesh_TAutoDiffXdU, vertex_tolerance: float = ...) -> bool: ...
    def element(self, e: int) -> VolumeElement: ...
    def num_elements(self) -> int: ...
    def num_vertices(self) -> int: ...
    def tetrahedra(self) -> List[VolumeElement]: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3, 1]]: ...
    def vertices(self) -> List[numpy.ndarray[object[3, 1]]]: ...

class _TemporaryName_N5drake8geometry10SceneGraphIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_TAutoDiffXdU):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    @overload
    def AddRenderer(self, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AddRenderer(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AddRenderer(self) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, PerceptionProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, IllustrationProperties) -> Any: ...
    @overload
    def ChangeShape(self, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self) -> Any: ...
    @overload
    def GetRendererTypeName(self, name: str) -> str: ...
    @overload
    def GetRendererTypeName(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, name: str) -> str: ...
    @overload
    def GetRendererTypeName(self) -> Any: ...
    @overload
    def HasRenderer(self, name: str) -> bool: ...
    @overload
    def HasRenderer(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, name: str) -> bool: ...
    @overload
    def HasRenderer(self) -> Any: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    @overload
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self) -> Any: ...
    @overload
    def RemoveRenderer(self, name: str) -> None: ...
    @overload
    def RemoveRenderer(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, name: str) -> None: ...
    @overload
    def RemoveRenderer(self) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_TAutoDiffXdU, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, GeometryId, Role) -> Any: ...
    def RenameFrame(self, frame_id: FrameId, name: str) -> None: ...
    def RenameGeometry(self, geometry_id: GeometryId, name: str) -> None: ...
    @overload
    def RendererCount(self) -> int: ...
    @overload
    def RendererCount(self, context: pydrake.systems.framework.Context_TAutoDiffXdU) -> int: ...
    @overload
    def RendererCount(self) -> Any: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_TAutoDiffXdU) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_TAutoDiffXdU: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_TAutoDiffXdU: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_TAutoDiffXdU: ...
    def model_inspector(self) -> SceneGraphInspector_TAutoDiffXdU: ...
    @classmethod
    def world_frame_id(cls) -> FrameId: ...

class _TemporaryName_N5drake8geometry10SceneGraphINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_TExpressionU):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    @overload
    def AddRenderer(self, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AddRenderer(self, context: pydrake.systems.framework.Context_TExpressionU, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AddRenderer(self) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, geometry_id: GeometryId, properties: PerceptionProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, PerceptionProperties) -> Any: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, geometry_id: GeometryId, properties: IllustrationProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, IllustrationProperties) -> Any: ...
    @overload
    def ChangeShape(self, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self) -> Any: ...
    @overload
    def GetRendererTypeName(self, name: str) -> str: ...
    @overload
    def GetRendererTypeName(self, context: pydrake.systems.framework.Context_TExpressionU, name: str) -> str: ...
    @overload
    def GetRendererTypeName(self) -> Any: ...
    @overload
    def HasRenderer(self, name: str) -> bool: ...
    @overload
    def HasRenderer(self, context: pydrake.systems.framework.Context_TExpressionU, name: str) -> bool: ...
    @overload
    def HasRenderer(self) -> Any: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterGeometry(self) -> Any: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    @overload
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    @overload
    def RemoveGeometry(self) -> Any: ...
    @overload
    def RemoveRenderer(self, name: str) -> None: ...
    @overload
    def RemoveRenderer(self, context: pydrake.systems.framework.Context_TExpressionU, name: str) -> None: ...
    @overload
    def RemoveRenderer(self) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    @overload
    def RemoveRole(self, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_TExpressionU, source_id: SourceId, geometry_id: GeometryId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, GeometryId, Role) -> Any: ...
    def RenameFrame(self, frame_id: FrameId, name: str) -> None: ...
    def RenameGeometry(self, geometry_id: GeometryId, name: str) -> None: ...
    @overload
    def RendererCount(self) -> int: ...
    @overload
    def RendererCount(self, context: pydrake.systems.framework.Context_TExpressionU) -> int: ...
    @overload
    def RendererCount(self) -> Any: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_TExpressionU) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_TExpressionU: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_TExpressionU: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_TExpressionU: ...
    def model_inspector(self) -> SceneGraphInspector_TExpressionU: ...
    @classmethod
    def world_frame_id(cls) -> FrameId: ...

class _TemporaryName_N5drake8geometry10VolumeMeshIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, elements: List[VolumeElement], vertices: List[numpy.ndarray[object[3, 1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[object[3, 1]], e: int) -> numpy.ndarray[object[4, 1]]: ...
    def CalcTetrahedronVolume(self, e: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcVolume(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def Equal(self, mesh: VolumeMesh_TAutoDiffXdU, vertex_tolerance: float = ...) -> bool: ...
    def element(self, e: int) -> VolumeElement: ...
    def num_elements(self) -> int: ...
    def num_vertices(self) -> int: ...
    def tetrahedra(self) -> List[VolumeElement]: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3, 1]]: ...
    def vertices(self) -> List[numpy.ndarray[object[3, 1]]]: ...

class _TemporaryName_N5drake8geometry11QueryObjectIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputeContactSurfaces(self, *args, **kwargs): ...
    def ComputeContactSurfacesWithFallback(self, *args, **kwargs): ...
    def ComputePointPairPenetration(self, *args, **kwargs): ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs): ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs): ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs): ...
    def FindCollisionCandidates(self, *args, **kwargs): ...
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_TAutoDiffXdU: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_TAutoDiffXdU: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_TAutoDiffXdU: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs): ...
    def RenderDepthImage(self, *args, **kwargs): ...
    def RenderLabelImage(self, *args, **kwargs): ...
    def inspector(self) -> SceneGraphInspector_TAutoDiffXdU: ...

class _TemporaryName_N5drake8geometry11QueryObjectINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputePointPairPenetration(self, *args, **kwargs): ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs): ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs): ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs): ...
    def FindCollisionCandidates(self, *args, **kwargs): ...
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_TExpressionU: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_TExpressionU: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_TExpressionU: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs): ...
    def RenderDepthImage(self, *args, **kwargs): ...
    def RenderLabelImage(self, *args, **kwargs): ...
    def inspector(self) -> SceneGraphInspector_TExpressionU: ...

class _TemporaryName_N5drake8geometry14ContactSurfaceIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Equal(self, surface: ContactSurface_TAutoDiffXdU) -> bool: ...
    def EvaluateGradE_M_W(self, index: int) -> numpy.ndarray[object[3, 1]]: ...
    def EvaluateGradE_N_W(self, index: int) -> numpy.ndarray[object[3, 1]]: ...
    def HasGradE_M(self) -> bool: ...
    def HasGradE_N(self) -> bool: ...
    def area(self, face_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def centroid(self, face_index: int) -> numpy.ndarray[object[3, 1]]: ...
    @overload
    def centroid(self) -> numpy.ndarray[object[3, 1]]: ...
    def face_normal(self, face_index: int) -> numpy.ndarray[object[3, 1]]: ...
    def id_M(self) -> GeometryId: ...
    def id_N(self) -> GeometryId: ...
    def is_triangle(self) -> bool: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def poly_e_MN(self) -> PolygonSurfaceMeshFieldLinear_TAutoDiffXdcAutoDiffXdU: ...
    def poly_mesh_W(self) -> PolygonSurfaceMesh_TAutoDiffXdU: ...
    def representation(self) -> HydroelasticContactRepresentation: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def tri_e_MN(self) -> TriangleSurfaceMeshFieldLinear_TAutoDiffXdcAutoDiffXdU: ...
    def tri_mesh_W(self) -> TriangleSurfaceMesh_TAutoDiffXdU: ...
    def __copy__(self) -> ContactSurface_TAutoDiffXdU: ...
    def __deepcopy__(self, arg0: dict) -> ContactSurface_TAutoDiffXdU: ...

class _TemporaryName_N5drake8geometry15DrakeVisualizerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_TAutoDiffXdU):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> None: ...
    @overload
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_TAutoDiffXdU, scene_graph: SceneGraph_TAutoDiffXdU, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> DrakeVisualizer_TAutoDiffXdU: ...
    @overload
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_TAutoDiffXdU, query_object_port: pydrake.systems.framework.OutputPort_TAutoDiffXdU, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> DrakeVisualizer_TAutoDiffXdU: ...
    @classmethod
    def DispatchLoadMessage(cls, scene_graph: SceneGraph_TAutoDiffXdU, lcm: pydrake.lcm.DrakeLcmInterface, params: DrakeVisualizerParams = ...) -> None: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_TAutoDiffXdU: ...

class _TemporaryName_N5drake8geometry15MeshFieldLinearIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEENS0_18PolygonSurfaceMeshIS6_EEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def EvaluateAtVertex(self, v: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[object[3, 1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateGradient(self, e: int) -> numpy.ndarray[object[3, 1]]: ...

class _TemporaryName_N5drake8geometry15MeshFieldLinearIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEENS0_19TriangleSurfaceMeshIS6_EEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Evaluate(self, e: int, b: numpy.ndarray[object[3, 1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateAtVertex(self, v: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[object[3, 1]]) -> pydrake.autodiffutils.AutoDiffXd: ...

class _TemporaryName_N5drake8geometry16KinematicsVectorINS_10IdentifierINS0_8FrameTagEEENS_4math14RigidTransformIN5Eigen14AutoDiffScalarINS7_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_TAutoDiffXdU) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_TAutoDiffXdU: ...

class _TemporaryName_N5drake8geometry16KinematicsVectorINS_10IdentifierINS0_8FrameTagEEENS_4math14RigidTransformINS_8symbolic10ExpressionEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_TExpressionU) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_TExpressionU: ...

class _TemporaryName_N5drake8geometry17MeshcatVisualizerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_TAutoDiffXdU):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> None: ...
    @overload
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_TAutoDiffXdU, scene_graph: SceneGraph_TAutoDiffXdU, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> MeshcatVisualizer_TAutoDiffXdU: ...
    @overload
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_TAutoDiffXdU, query_object_port: pydrake.systems.framework.OutputPort_TAutoDiffXdU, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> MeshcatVisualizer_TAutoDiffXdU: ...
    def Delete(self) -> None: ...
    def DeleteRecording(self) -> None: ...
    def PublishRecording(self) -> None: ...
    def ResetRealtimeRateCalculator(self) -> None: ...
    def StartRecording(self, set_transforms_while_recording: bool = ...) -> MeshcatAnimation: ...
    def StopRecording(self) -> None: ...
    def get_mutable_recording(self) -> MeshcatAnimation: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_TAutoDiffXdU: ...

class _TemporaryName_N5drake8geometry18PolygonSurfaceMeshIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, face_data: List[int], vertices: List[numpy.ndarray[object[3, 1]]]) -> None: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[object[3, 1]], numpy.ndarray[object[3, 1]]]: ...
    def Equal(self, mesh: PolygonSurfaceMesh_TAutoDiffXdU) -> bool: ...
    def area(self, f: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def centroid(self) -> numpy.ndarray[object[3, 1]]: ...
    def element(self, e: int) -> SurfacePolygon: ...
    def element_centroid(self, e: int) -> numpy.ndarray[object[3, 1]]: ...
    def face_data(self) -> List[int]: ...
    def face_normal(self, f: int) -> numpy.ndarray[object[3, 1]]: ...
    def num_elements(self) -> int: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3, 1]]: ...
    def __copy__(self) -> PolygonSurfaceMesh_TAutoDiffXdU: ...
    def __deepcopy__(self, arg0: dict) -> PolygonSurfaceMesh_TAutoDiffXdU: ...

class _TemporaryName_N5drake8geometry18SignedDistancePairIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.autodiffutils.AutoDiffXd
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3, 1]]
    p_ACa: numpy.ndarray[object[3, 1]]
    p_BCb: numpy.ndarray[object[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry18SignedDistancePairINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.symbolic.Expression
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3, 1]]
    p_ACa: numpy.ndarray[object[3, 1]]
    p_BCb: numpy.ndarray[object[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry19SceneGraphInspectorIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetAllSourceIds(self) -> List[SourceId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId, GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None, TriangleSurfaceMesh, VolumeMesh]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class _TemporaryName_N5drake8geometry19SceneGraphInspectorINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetAllSourceIds(self) -> List[SourceId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId, GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None, TriangleSurfaceMesh, VolumeMesh]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class _TemporaryName_N5drake8geometry19TriangleSurfaceMeshIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, triangles: List[SurfaceTriangle], vertices: List[numpy.ndarray[object[3, 1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[object[3, 1]], t: int) -> numpy.ndarray[object[3, 1]]: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[object[3, 1]], numpy.ndarray[object[3, 1]]]: ...
    def CalcCartesianFromBarycentric(self, element_index: int, b_Q: numpy.ndarray[object[3, 1]]) -> numpy.ndarray[object[3, 1]]: ...
    def Equal(self, mesh: TriangleSurfaceMesh_TAutoDiffXdU) -> bool: ...
    def area(self, t: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def centroid(self) -> numpy.ndarray[object[3, 1]]: ...
    def element(self, e: int) -> SurfaceTriangle: ...
    def element_centroid(self, t: int) -> numpy.ndarray[object[3, 1]]: ...
    def face_normal(self, t: int) -> numpy.ndarray[object[3, 1]]: ...
    def num_elements(self) -> int: ...
    def num_triangles(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def triangles(self) -> List[SurfaceTriangle]: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3, 1]]: ...
    def vertices(self) -> List[numpy.ndarray[object[3, 1]]]: ...

class _TemporaryName_N5drake8geometry21SignedDistanceToPointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.autodiffutils.AutoDiffXd
    grad_W: numpy.ndarray[object[3, 1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[object[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry21SignedDistanceToPointINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.symbolic.Expression
    grad_W: numpy.ndarray[object[3, 1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[object[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry22PenetrationAsPointPairIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: pydrake.autodiffutils.AutoDiffXd
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3, 1]]
    p_WCa: numpy.ndarray[object[3, 1]]
    p_WCb: numpy.ndarray[object[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry22PenetrationAsPointPairINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: pydrake.symbolic.Expression
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3, 1]]
    p_WCa: numpy.ndarray[object[3, 1]]
    p_WCb: numpy.ndarray[object[3, 1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry27MeshcatPointCloudVisualizerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_TAutoDiffXdU):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, path: str, publish_period: float = ...) -> None: ...
    @overload
    def Delete(self) -> None: ...
    @overload
    def Delete(self, path) -> Any: ...
    def cloud_input_port(self) -> pydrake.systems.framework.InputPort_TAutoDiffXdU: ...
    def pose_input_port(self) -> pydrake.systems.framework.InputPort_TAutoDiffXdU: ...
    def set_default_rgba(self, arg0: Rgba) -> None: ...
    def set_point_size(self, arg0: float) -> None: ...

def AddCompliantHydroelasticProperties(resolution_hint: float, hydroelastic_modulus: float, properties: ProximityProperties) -> None: ...
def AddCompliantHydroelasticPropertiesForHalfSpace(slab_thickness: float, hydroelastic_modulus: float, properties: ProximityProperties) -> None: ...
@overload
def AddContactMaterial(dissipation: Optional[float], point_stiffness: Optional[float], friction, properties: ProximityProperties) -> None: ...
@overload
def AddContactMaterial() -> Any: ...
@overload
def AddContactMaterial(properties: ProximityProperties, dissipation: Optional[float] = ..., point_stiffness: Optional[float] = ..., friction=...) -> None: ...
@overload
def AddContactMaterial() -> Any: ...
@overload
def AddRigidHydroelasticProperties(resolution_hint: float, properties: ProximityProperties) -> None: ...
@overload
def AddRigidHydroelasticProperties(properties: ProximityProperties) -> None: ...
def CalcVolume(shape: Shape) -> float: ...
@overload
def ConvertVolumeToSurfaceMesh(volume: VolumeMesh) -> TriangleSurfaceMesh: ...
@overload
def ConvertVolumeToSurfaceMesh(volume: VolumeMesh_TAutoDiffXdU) -> TriangleSurfaceMesh_TAutoDiffXdU: ...
def MakePhongIllustrationProperties(diffuse: numpy.ndarray[numpy.float64[4, 1]]) -> IllustrationProperties: ...
def MakeRenderEngineGl(params: RenderEngineGlParams = ...) -> RenderEngine: ...
@overload
def MakeRenderEngineGltfClient(params: RenderEngineGltfClientParams = ...) -> RenderEngine: ...
@overload
def MakeRenderEngineGltfClient(params) -> Any: ...
@overload
def MakeRenderEngineGltfClient() -> Any: ...
def MakeRenderEngineVtk(params: RenderEngineVtkParams) -> RenderEngine: ...
def ReadObjToTriangleSurfaceMesh(filename: str, scale: float = ...) -> TriangleSurfaceMesh: ...
