import flags
import numpy
import pydrake.common.eigen_geometry
import pydrake.geometry
import pydrake.math
import pydrake.multibody.plant
import pydrake.multibody.tree
import pydrake.planning
import pydrake.solvers
import pydrake.systems.framework
from typing import Callable, ClassVar, List, Optional, Tuple, overload

class AngleBetweenVectorsConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, frameA: pydrake.multibody.tree.Frame, a_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, b_B: numpy.ndarray[numpy.float64[3, 1]], angle_lower: float, angle_upper: float, plant_context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, frameA: pydrake.multibody.tree.Frame_TAutoDiffXdU, a_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame_TAutoDiffXdU, b_B: numpy.ndarray[numpy.float64[3, 1]], angle_lower: float, angle_upper: float, plant_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> None: ...

class AngleBetweenVectorsCost(pydrake.solvers.Cost):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, frameA: pydrake.multibody.tree.Frame, a_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, b_B: numpy.ndarray[numpy.float64[3, 1]], c: float, plant_context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, frameA: pydrake.multibody.tree.Frame_TAutoDiffXdU, a_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame_TAutoDiffXdU, b_B: numpy.ndarray[numpy.float64[3, 1]], c: float, plant_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> None: ...

class ComInPolyhedronConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, model_instances: Optional[List[pydrake.multibody.tree.ModelInstanceIndex]], expressed_frame: pydrake.multibody.tree.Frame, A: numpy.ndarray[numpy.float64[m, 3], flags.f_contiguous], lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], plant_context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, model_instances: Optional[List[pydrake.multibody.tree.ModelInstanceIndex]], expressed_frame: pydrake.multibody.tree.Frame_TAutoDiffXdU, A: numpy.ndarray[numpy.float64[m, 3], flags.f_contiguous], lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], plant_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> None: ...

class ComPositionConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, model_instances: Optional[List[pydrake.multibody.tree.ModelInstanceIndex]], expressed_frame: pydrake.multibody.tree.Frame, plant_context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, model_instances: Optional[List[pydrake.multibody.tree.ModelInstanceIndex]], expressed_frame: pydrake.multibody.tree.Frame_TAutoDiffXdU, plant_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> None: ...

class DifferentialInverseKinematicsIntegrator(pydrake.systems.framework.LeafSystem):
    @overload
    def __init__(self, robot: pydrake.multibody.plant.MultibodyPlant, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame, time_step: float, parameters: DifferentialInverseKinematicsParameters, robot_context: pydrake.systems.framework.Context = ..., log_only_when_result_state_changes: bool = ...) -> None: ...
    @overload
    def __init__(self, robot: pydrake.multibody.plant.MultibodyPlant, frame_E: pydrake.multibody.tree.Frame, time_step: float, parameters: DifferentialInverseKinematicsParameters, robot_context: pydrake.systems.framework.Context = ..., log_only_when_result_state_changes: bool = ...) -> None: ...
    def ForwardKinematics(self, context: pydrake.systems.framework.Context) -> pydrake.math.RigidTransform: ...
    def SetPositions(self, context: pydrake.systems.framework.Context, positions: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def get_mutable_parameters(self) -> DifferentialInverseKinematicsParameters: ...
    def get_parameters(self) -> DifferentialInverseKinematicsParameters: ...

class DifferentialInverseKinematicsParameters:
    def __init__(self, num_positions: int, num_velocities: int = ...) -> None: ...
    def get_end_effector_angular_speed_limit(self) -> float: ...
    def get_end_effector_translational_velocity_limits(self) -> Optional[Tuple[numpy.ndarray[numpy.float64[3, 1]], numpy.ndarray[numpy.float64[3, 1]]]]: ...
    def get_end_effector_velocity_flag(self) -> numpy.ndarray[bool[6, 1]]: ...
    def get_joint_acceleration_limits(self) -> Optional[Tuple[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, 1]]]]: ...
    def get_joint_centering_gain(self) -> numpy.ndarray[numpy.float64[m, n]]: ...
    def get_joint_position_limits(self) -> Optional[Tuple[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, 1]]]]: ...
    def get_joint_velocity_limits(self) -> Optional[Tuple[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, 1]]]]: ...
    def get_maximum_scaling_to_report_stuck(self) -> float: ...
    def get_nominal_joint_position(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def get_num_positions(self) -> int: ...
    def get_num_velocities(self) -> int: ...
    def get_time_step(self) -> float: ...
    def set_end_effector_angular_speed_limit(self, speed: float) -> None: ...
    def set_end_effector_translational_velocity_limits(self, lower: numpy.ndarray[numpy.float64[3, 1]], upper: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
    def set_end_effector_velocity_flag(self, flag_E: numpy.ndarray[bool[6, 1]]) -> None: ...
    def set_joint_acceleration_limits(self, arg0: Tuple[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, 1]]]) -> None: ...
    def set_joint_centering_gain(self, K: numpy.ndarray[numpy.float64[m, n]]) -> None: ...
    def set_joint_position_limits(self, arg0: Tuple[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, 1]]]) -> None: ...
    def set_joint_velocity_limits(self, arg0: Tuple[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, 1]]]) -> None: ...
    def set_maximum_scaling_to_report_stuck(self, scaling: float) -> None: ...
    def set_nominal_joint_position(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def set_time_step(self, dt: float) -> None: ...

class DifferentialInverseKinematicsResult:
    joint_velocities: Optional[numpy.ndarray[numpy.float64[m, 1]]]
    status: DifferentialInverseKinematicsStatus
    def __init__(self, **kwargs) -> None: ...

class DifferentialInverseKinematicsStatus:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kNoSolutionFound: ClassVar[DifferentialInverseKinematicsStatus] = ...
    kSolutionFound: ClassVar[DifferentialInverseKinematicsStatus] = ...
    kStuck: ClassVar[DifferentialInverseKinematicsStatus] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class DistanceConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, geometry_pair: Tuple[pydrake.geometry.GeometryId], plant_context: pydrake.systems.framework.Context, distance_lower: float, distance_upper: float) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, geometry_pair: Tuple[pydrake.geometry.GeometryId], plant_context: pydrake.systems.framework.Context_TAutoDiffXdU, distance_lower: float, distance_upper: float) -> None: ...

class GazeTargetConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, frameA: pydrake.multibody.tree.Frame, p_AS: numpy.ndarray[numpy.float64[3, 1]], n_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, p_BT: numpy.ndarray[numpy.float64[3, 1]], cone_half_angle: float, plant_context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, frameA: pydrake.multibody.tree.Frame_TAutoDiffXdU, p_AS: numpy.ndarray[numpy.float64[3, 1]], n_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame_TAutoDiffXdU, p_BT: numpy.ndarray[numpy.float64[3, 1]], cone_half_angle: float, plant_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> None: ...

class GlobalInverseKinematics:
    class Options:
        _pybind11_del_orig: ClassVar[None] = ...
        approach: pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach
        interval_binning: pydrake.solvers.IntervalBinning
        linear_constraint_only: bool
        num_intervals_per_half_axis: int
        def __init__(self) -> None: ...
        def __del__(self, *args, **kwargs) -> None: ...
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, options: GlobalInverseKinematics.Options = ...) -> None: ...
    def AddPostureCost(self, q_desired: numpy.ndarray[numpy.float64[m, 1]], body_position_cost: numpy.ndarray[numpy.float64[m, 1]], body_orientation_cost: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def AddWorldOrientationConstraint(self, body_index: pydrake.multibody.tree.BodyIndex, desired_orientation: pydrake.common.eigen_geometry.Quaternion, angle_tol: float) -> pydrake.solvers.BindingTLinearConstraintU: ...
    def AddWorldPositionConstraint(self, body_index: pydrake.multibody.tree.BodyIndex, p_BQ: numpy.ndarray[numpy.float64[3, 1]], box_lb_F: numpy.ndarray[numpy.float64[3, 1]], box_ub_F: numpy.ndarray[numpy.float64[3, 1]], X_WF: pydrake.math.RigidTransform = ...) -> pydrake.solvers.BindingTLinearConstraintU: ...
    def AddWorldRelativePositionConstraint(self, body_index_B: pydrake.multibody.tree.BodyIndex, p_BQ: numpy.ndarray[numpy.float64[3, 1]], body_index_A: pydrake.multibody.tree.BodyIndex, p_AP: numpy.ndarray[numpy.float64[3, 1]], box_lb_F: numpy.ndarray[numpy.float64[3, 1]], box_ub_F: numpy.ndarray[numpy.float64[3, 1]], X_WF: pydrake.math.RigidTransform = ...) -> pydrake.solvers.BindingTLinearConstraintU: ...
    def ReconstructGeneralizedPositionSolution(self, result: pydrake.solvers.MathematicalProgramResult) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def SetInitialGuess(self, q: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def body_position(self, body_index: pydrake.multibody.tree.BodyIndex) -> numpy.ndarray[object[3, 1]]: ...
    def body_rotation_matrix(self, body_index: pydrake.multibody.tree.BodyIndex) -> numpy.ndarray[object[3, 3]]: ...
    def get_mutable_prog(self) -> pydrake.solvers.MathematicalProgram: ...
    def prog(self) -> pydrake.solvers.MathematicalProgram: ...

class InverseKinematics:
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, with_joint_limits: bool = ...) -> None: ...
    def AddAngleBetweenVectorsConstraint(self, frameA: pydrake.multibody.tree.Frame, na_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, nb_B: numpy.ndarray[numpy.float64[3, 1]], angle_lower: float, angle_upper: float) -> pydrake.solvers.BindingTConstraintU: ...
    def AddAngleBetweenVectorsCost(self, frameA: pydrake.multibody.tree.Frame, na_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, nb_B: numpy.ndarray[numpy.float64[3, 1]], c: float) -> pydrake.solvers.BindingTCostU: ...
    def AddDistanceConstraint(self, geometry_pair: Tuple[pydrake.geometry.GeometryId], distance_lower: float, distance_upper: float) -> pydrake.solvers.BindingTConstraintU: ...
    def AddGazeTargetConstraint(self, frameA: pydrake.multibody.tree.Frame, p_AS: numpy.ndarray[numpy.float64[3, 1]], n_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, p_BT: numpy.ndarray[numpy.float64[3, 1]], cone_half_angle: float) -> pydrake.solvers.BindingTConstraintU: ...
    def AddMinimumDistanceLowerBoundConstraint(self, bound: float, influence_distance_offset: float = ...) -> pydrake.solvers.BindingTConstraintU: ...
    def AddMinimumDistanceUpperBoundConstraint(self, bound: float, influence_distance_offset: float) -> pydrake.solvers.BindingTConstraintU: ...
    def AddOrientationConstraint(self, frameAbar: pydrake.multibody.tree.Frame, R_AbarA: pydrake.math.RotationMatrix, frameBbar: pydrake.multibody.tree.Frame, R_BbarB: pydrake.math.RotationMatrix, theta_bound: float) -> pydrake.solvers.BindingTConstraintU: ...
    def AddOrientationCost(self, frameAbar: pydrake.multibody.tree.Frame, R_AbarA: pydrake.math.RotationMatrix, frameBbar: pydrake.multibody.tree.Frame, R_BbarB: pydrake.math.RotationMatrix, c: float) -> pydrake.solvers.BindingTCostU: ...
    def AddPointToLineDistanceConstraint(self, frame_point: pydrake.multibody.tree.Frame, p_B1P: numpy.ndarray[numpy.float64[3, 1]], frame_line: pydrake.multibody.tree.Frame, p_B2Q: numpy.ndarray[numpy.float64[3, 1]], n_B2: numpy.ndarray[numpy.float64[3, 1]], distance_lower: float, distance_upper: float) -> pydrake.solvers.BindingTConstraintU: ...
    def AddPointToPointDistanceConstraint(self, frame1: pydrake.multibody.tree.Frame, p_B1P1: numpy.ndarray[numpy.float64[3, 1]], frame2: pydrake.multibody.tree.Frame, p_B2P2: numpy.ndarray[numpy.float64[3, 1]], distance_lower: float, distance_upper: float) -> pydrake.solvers.BindingTConstraintU: ...
    def AddPolyhedronConstraint(self, frameF: pydrake.multibody.tree.Frame, frameG: pydrake.multibody.tree.Frame, p_GP: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]]) -> pydrake.solvers.BindingTConstraintU: ...
    @overload
    def AddPositionConstraint(self, frameB: pydrake.multibody.tree.Frame, p_BQ: numpy.ndarray[numpy.float64[3, 1]], frameA: pydrake.multibody.tree.Frame, p_AQ_lower: numpy.ndarray[numpy.float64[3, 1]], p_AQ_upper: numpy.ndarray[numpy.float64[3, 1]]) -> pydrake.solvers.BindingTConstraintU: ...
    @overload
    def AddPositionConstraint(self, frameB: pydrake.multibody.tree.Frame, p_BQ: numpy.ndarray[numpy.float64[3, 1]], frameAbar: pydrake.multibody.tree.Frame, X_AbarA: Optional[pydrake.math.RigidTransform], p_AQ_lower: numpy.ndarray[numpy.float64[3, 1]], p_AQ_upper: numpy.ndarray[numpy.float64[3, 1]]) -> pydrake.solvers.BindingTConstraintU: ...
    def AddPositionCost(self, frameA: pydrake.multibody.tree.Frame, p_AP: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, p_BQ: numpy.ndarray[numpy.float64[3, 1]], C: numpy.ndarray[numpy.float64[3, 3], flags.f_contiguous]) -> pydrake.solvers.BindingTCostU: ...
    def context(self) -> pydrake.systems.framework.Context: ...
    def get_mutable_context(self) -> pydrake.systems.framework.Context: ...
    def get_mutable_prog(self) -> pydrake.solvers.MathematicalProgram: ...
    def prog(self) -> pydrake.solvers.MathematicalProgram: ...
    def q(self) -> numpy.ndarray[object[m, 1]]: ...

class MinimumDistanceLowerBoundConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, bound: float, plant_context: pydrake.systems.framework.Context, penalty_function: Callable[[float, bool], tuple] = ..., influence_distance_offset: float = ...) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, bound: float, plant_context: pydrake.systems.framework.Context_TAutoDiffXdU, penalty_function: Callable[[float, bool], tuple] = ..., influence_distance_offset: float = ...) -> None: ...
    @overload
    def __init__(self, collision_checker: pydrake.planning.CollisionChecker, bound: float, collision_checker_context: pydrake.planning.CollisionCheckerContext, penalty_function: Callable[[float, bool], tuple] = ..., influence_distance_offset: float = ...) -> None: ...
    def distance_bound(self) -> float: ...
    def influence_distance(self) -> float: ...

class MinimumDistanceUpperBoundConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, bound: float, plant_context: pydrake.systems.framework.Context, influence_distance_offset: float, penalty_function: Callable[[float, bool], tuple] = ...) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, bound: float, plant_context: pydrake.systems.framework.Context_TAutoDiffXdU, influence_distance_offset: float, penalty_function: Callable[[float, bool], tuple] = ...) -> None: ...
    @overload
    def __init__(self, collision_checker: pydrake.planning.CollisionChecker, bound: float, collision_checker_context: pydrake.planning.CollisionCheckerContext, influence_distance_offset: float, penalty_function: Callable[[float, bool], tuple] = ...) -> None: ...
    def distance_bound(self) -> float: ...
    def influence_distance(self) -> float: ...

class OrientationConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, frameAbar: pydrake.multibody.tree.Frame, R_AbarA: pydrake.math.RotationMatrix, frameBbar: pydrake.multibody.tree.Frame, R_BbarB: pydrake.math.RotationMatrix, theta_bound: float, plant_context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, frameAbar: pydrake.multibody.tree.Frame_TAutoDiffXdU, R_AbarA: pydrake.math.RotationMatrix, frameBbar: pydrake.multibody.tree.Frame_TAutoDiffXdU, R_BbarB: pydrake.math.RotationMatrix, theta_bound: float, plant_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> None: ...

class OrientationCost(pydrake.solvers.Cost):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, frameAbar: pydrake.multibody.tree.Frame, R_AbarA: pydrake.math.RotationMatrix, frameBbar: pydrake.multibody.tree.Frame, R_BbarB: pydrake.math.RotationMatrix, c: float, plant_context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, frameAbar: pydrake.multibody.tree.Frame_TAutoDiffXdU, R_AbarA: pydrake.math.RotationMatrix, frameBbar: pydrake.multibody.tree.Frame_TAutoDiffXdU, R_BbarB: pydrake.math.RotationMatrix, c: float, plant_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> None: ...

class PointToLineDistanceConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, frame_point: pydrake.multibody.tree.Frame, p_B1P: numpy.ndarray[numpy.float64[3, 1]], frame_line: pydrake.multibody.tree.Frame, p_B2Q: numpy.ndarray[numpy.float64[3, 1]], n_B2: numpy.ndarray[numpy.float64[3, 1]], distance_lower: float, distance_upper: float, plant_context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, frame_point: pydrake.multibody.tree.Frame_TAutoDiffXdU, p_B1P: numpy.ndarray[numpy.float64[3, 1]], frame_line: pydrake.multibody.tree.Frame_TAutoDiffXdU, p_B2Q: numpy.ndarray[numpy.float64[3, 1]], n_B2: numpy.ndarray[numpy.float64[3, 1]], distance_lower: float, distance_upper: float, plant_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> None: ...

class PointToPointDistanceConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, frame1: pydrake.multibody.tree.Frame, p_B1P1: numpy.ndarray[numpy.float64[3, 1]], frame2: pydrake.multibody.tree.Frame, p_B2P2: numpy.ndarray[numpy.float64[3, 1]], distance_lower: float, distance_upper: float, plant_context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, frame1: pydrake.multibody.tree.Frame_TAutoDiffXdU, p_B1P1: numpy.ndarray[numpy.float64[3, 1]], frame2: pydrake.multibody.tree.Frame_TAutoDiffXdU, p_B2P2: numpy.ndarray[numpy.float64[3, 1]], distance_lower: float, distance_upper: float, plant_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> None: ...

class PolyhedronConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, frameF: pydrake.multibody.tree.Frame, frameG: pydrake.multibody.tree.Frame, p_GP: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], plant_context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, frameF: pydrake.multibody.tree.Frame_TAutoDiffXdU, frameG: pydrake.multibody.tree.Frame_TAutoDiffXdU, p_GP: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], plant_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> None: ...

class PositionConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, frameA: pydrake.multibody.tree.Frame, p_AQ_lower: numpy.ndarray[numpy.float64[3, 1]], p_AQ_upper: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, p_BQ: numpy.ndarray[numpy.float64[3, 1]], plant_context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, frameAbar: pydrake.multibody.tree.Frame, X_AbarA: Optional[pydrake.math.RigidTransform], p_AQ_lower: numpy.ndarray[numpy.float64[3, 1]], p_AQ_upper: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, p_BQ: numpy.ndarray[numpy.float64[3, 1]], plant_context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, frameA: pydrake.multibody.tree.Frame_TAutoDiffXdU, p_AQ_lower: numpy.ndarray[numpy.float64[3, 1]], p_AQ_upper: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame_TAutoDiffXdU, p_BQ: numpy.ndarray[numpy.float64[3, 1]], plant_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, frameAbar: pydrake.multibody.tree.Frame_TAutoDiffXdU, X_AbarA: Optional[pydrake.math.RigidTransform], p_AQ_lower: numpy.ndarray[numpy.float64[3, 1]], p_AQ_upper: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame_TAutoDiffXdU, p_BQ: numpy.ndarray[numpy.float64[3, 1]], plant_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> None: ...
    def UpdateLowerBound(self, new_lb: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def UpdateUpperBound(self, new_ub: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def set_bounds(self, new_lb: numpy.ndarray[numpy.float64[m, 1]], new_ub: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...

class PositionCost(pydrake.solvers.Cost):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, frameA: pydrake.multibody.tree.Frame, p_AP: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, p_BQ: numpy.ndarray[numpy.float64[3, 1]], C: numpy.ndarray[numpy.float64[3, 3], flags.f_contiguous], plant_context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, frameA: pydrake.multibody.tree.Frame_TAutoDiffXdU, p_AP: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame_TAutoDiffXdU, p_BQ: numpy.ndarray[numpy.float64[3, 1]], C: numpy.ndarray[numpy.float64[3, 3], flags.f_contiguous], plant_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> None: ...

class UnitQuaternionConstraint(pydrake.solvers.Constraint):
    def __init__(self) -> None: ...

@overload
def AddUnitQuaternionConstraintOnPlant(plant: pydrake.multibody.plant.MultibodyPlant, q_vars: numpy.ndarray[object[m, 1]], prog: pydrake.solvers.MathematicalProgram) -> None: ...
@overload
def AddUnitQuaternionConstraintOnPlant(plant: pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU, q_vars: numpy.ndarray[object[m, 1]], prog: pydrake.solvers.MathematicalProgram) -> None: ...
def DoDifferentialInverseKinematics(*args, **kwargs): ...
