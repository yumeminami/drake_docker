import flags
import numpy
import pydrake.common
import pydrake.geometry
import pydrake.geometry.optimization
import pydrake.math
import pydrake.multibody.parsing
import pydrake.multibody.plant
import pydrake.multibody.tree
import pydrake.solvers
import pydrake.symbolic
import pydrake.systems.framework
import pydrake.trajectories
import scipy.sparse
from pydrake.common.cpp_template import RobotDiagramBuilder_ as RobotDiagramBuilder_, RobotDiagram_ as RobotDiagram_
from typing import Any, Callable, ClassVar, Dict, List, Optional, Tuple, Union, overload

class BodyShapeDescription:
    @overload
    def __init__(self, shape: pydrake.geometry.Shape, X_BS: pydrake.math.RigidTransform, model_instance_name: str, body_name: str) -> None: ...
    @overload
    def __init__(self, other: BodyShapeDescription) -> None: ...
    def body_name(self) -> str: ...
    def model_instance_name(self) -> str: ...
    def pose_in_body(self) -> pydrake.math.RigidTransform: ...
    def shape(self) -> pydrake.geometry.Shape: ...
    def __copy__(self) -> BodyShapeDescription: ...
    def __deepcopy__(self, arg0: dict) -> BodyShapeDescription: ...

class CollisionChecker:
    def __init__(self, *args, **kwargs) -> None: ...
    def AddCollisionShape(self, group_name: str, description: BodyShapeDescription) -> bool: ...
    def AddCollisionShapeToBody(self, group_name: str, bodyA: pydrake.multibody.tree.RigidBody, shape: pydrake.geometry.Shape, X_AG: pydrake.math.RigidTransform) -> bool: ...
    def AddCollisionShapeToFrame(self, group_name: str, frameA: pydrake.multibody.tree.Frame, shape: pydrake.geometry.Shape, X_AG: pydrake.math.RigidTransform) -> bool: ...
    @overload
    def AddCollisionShapes(self, group_name: str, descriptions: List[BodyShapeDescription]) -> int: ...
    @overload
    def AddCollisionShapes(self, geometry_groups: Dict[str, List[BodyShapeDescription]]) -> Dict[str, int]: ...
    def CalcContextRobotClearance(self, model_context: CollisionCheckerContext, q: numpy.ndarray[numpy.float64[m, 1]], influence_distance: float) -> RobotClearance: ...
    def CalcRobotClearance(self, q: numpy.ndarray[numpy.float64[m, 1]], influence_distance: float, context_number: Optional[int] = ...) -> RobotClearance: ...
    def CheckConfigCollisionFree(self, q: numpy.ndarray[numpy.float64[m, 1]], context_number: Optional[int] = ...) -> bool: ...
    def CheckConfigsCollisionFree(self, configs: List[numpy.ndarray[numpy.float64[m, 1]]], parallelize: pydrake.common.Parallelism = ...) -> List[int]: ...
    def CheckContextConfigCollisionFree(self, model_context: CollisionCheckerContext, q: numpy.ndarray[numpy.float64[m, 1]]) -> bool: ...
    def CheckContextEdgeCollisionFree(self, model_context: CollisionCheckerContext, q1: numpy.ndarray[numpy.float64[m, 1]], q2: numpy.ndarray[numpy.float64[m, 1]]) -> bool: ...
    def CheckEdgeCollisionFree(self, q1: numpy.ndarray[numpy.float64[m, 1]], q2: numpy.ndarray[numpy.float64[m, 1]], context_number: Optional[int] = ...) -> bool: ...
    def CheckEdgeCollisionFreeParallel(self, q1: numpy.ndarray[numpy.float64[m, 1]], q2: numpy.ndarray[numpy.float64[m, 1]], parallelize: pydrake.common.Parallelism = ...) -> bool: ...
    def CheckEdgesCollisionFree(self, edges: List[Tuple[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, 1]]]], parallelize: pydrake.common.Parallelism = ...) -> List[int]: ...
    def ClassifyBodyCollisions(self, q: numpy.ndarray[numpy.float64[m, 1]], context_number: Optional[int] = ...) -> List[RobotCollisionType]: ...
    def ClassifyContextBodyCollisions(self, model_context: CollisionCheckerContext, q: numpy.ndarray[numpy.float64[m, 1]]) -> List[RobotCollisionType]: ...
    def Clone(self) -> CollisionChecker: ...
    def ComputeConfigurationDistance(self, q1: numpy.ndarray[numpy.float64[m, 1]], q2: numpy.ndarray[numpy.float64[m, 1]]) -> float: ...
    def GetAllAddedCollisionShapes(self) -> Dict[str, List[BodyShapeDescription]]: ...
    def GetFilteredCollisionMatrix(self) -> numpy.ndarray[numpy.int32[m, n]]: ...
    def GetLargestPadding(self) -> float: ...
    def GetNominalFilteredCollisionMatrix(self) -> numpy.ndarray[numpy.int32[m, n]]: ...
    @overload
    def GetPaddingBetween(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex) -> float: ...
    @overload
    def GetPaddingBetween(self, bodyA: pydrake.multibody.tree.RigidBody, bodyB: pydrake.multibody.tree.RigidBody) -> float: ...
    def GetPaddingMatrix(self) -> numpy.ndarray[numpy.float64[m, n]]: ...
    def GetZeroConfiguration(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def InterpolateBetweenConfigurations(self, q1: numpy.ndarray[numpy.float64[m, 1]], q2: numpy.ndarray[numpy.float64[m, 1]], ratio: float) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    @overload
    def IsCollisionFilteredBetween(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex) -> bool: ...
    @overload
    def IsCollisionFilteredBetween(self, bodyA: pydrake.multibody.tree.RigidBody, bodyB: pydrake.multibody.tree.RigidBody) -> bool: ...
    @overload
    def IsPartOfRobot(self, body: pydrake.multibody.tree.RigidBody) -> bool: ...
    @overload
    def IsPartOfRobot(self, body_index: pydrake.multibody.tree.BodyIndex) -> bool: ...
    def MakeStandaloneConfigurationDistanceFunction(self) -> Callable[[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, 1]]], float]: ...
    def MakeStandaloneConfigurationInterpolationFunction(self) -> Callable[[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, 1]], float], numpy.ndarray[numpy.float64[m, 1]]]: ...
    def MakeStandaloneModelContext(self) -> CollisionCheckerContext: ...
    def MaxContextNumDistances(self, model_context: CollisionCheckerContext) -> int: ...
    def MaxNumDistances(self, context_number: Optional[int] = ...) -> int: ...
    def MaybeGetUniformRobotEnvironmentPadding(self) -> Optional[float]: ...
    def MaybeGetUniformRobotRobotPadding(self) -> Optional[float]: ...
    def MeasureContextEdgeCollisionFree(self, model_context: CollisionCheckerContext, q1: numpy.ndarray[numpy.float64[m, 1]], q2: numpy.ndarray[numpy.float64[m, 1]]) -> EdgeMeasure: ...
    def MeasureEdgeCollisionFree(self, q1: numpy.ndarray[numpy.float64[m, 1]], q2: numpy.ndarray[numpy.float64[m, 1]], context_number: Optional[int] = ...) -> EdgeMeasure: ...
    def MeasureEdgeCollisionFreeParallel(self, q1: numpy.ndarray[numpy.float64[m, 1]], q2: numpy.ndarray[numpy.float64[m, 1]], parallelize: pydrake.common.Parallelism = ...) -> EdgeMeasure: ...
    def MeasureEdgesCollisionFree(self, edges: List[Tuple[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, 1]]]], parallelize: pydrake.common.Parallelism = ...) -> List[EdgeMeasure]: ...
    def PerformOperationAgainstAllModelContexts(self, operation: Callable[[RobotDiagram, CollisionCheckerContext], None]) -> None: ...
    @overload
    def RemoveAllAddedCollisionShapes(self, group_name: str) -> None: ...
    @overload
    def RemoveAllAddedCollisionShapes(self) -> None: ...
    def SetCollisionFilterMatrix(self, filter_matrix: numpy.ndarray[numpy.int32[m, n]]) -> None: ...
    @overload
    def SetCollisionFilteredBetween(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, filter_collision: bool) -> None: ...
    @overload
    def SetCollisionFilteredBetween(self, bodyA: pydrake.multibody.tree.RigidBody, bodyB: pydrake.multibody.tree.RigidBody, filter_collision: bool) -> None: ...
    @overload
    def SetCollisionFilteredWithAllBodies(self, body_index: pydrake.multibody.tree.BodyIndex) -> None: ...
    @overload
    def SetCollisionFilteredWithAllBodies(self, body: pydrake.multibody.tree.RigidBody) -> None: ...
    def SetConfigurationDistanceFunction(self, distance_function: Callable[[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, 1]]], float]) -> None: ...
    def SetConfigurationInterpolationFunction(self, interpolation_function: Callable[[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, 1]], float], numpy.ndarray[numpy.float64[m, 1]]]) -> None: ...
    def SetDistanceAndInterpolationProvider(self, provider: DistanceAndInterpolationProvider) -> None: ...
    def SetPaddingAllRobotEnvironmentPairs(self, padding: float) -> None: ...
    def SetPaddingAllRobotRobotPairs(self, padding: float) -> None: ...
    @overload
    def SetPaddingBetween(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, padding: float) -> None: ...
    @overload
    def SetPaddingBetween(self, bodyA: pydrake.multibody.tree.RigidBody, bodyB: pydrake.multibody.tree.RigidBody, padding: float) -> None: ...
    def SetPaddingMatrix(self, collision_padding: numpy.ndarray[numpy.float64[m, n]]) -> None: ...
    def SetPaddingOneRobotBodyAllEnvironmentPairs(self, body_index: pydrake.multibody.tree.BodyIndex, padding: float) -> None: ...
    def SupportsParallelChecking(self) -> bool: ...
    def UpdateContextPositions(self, model_context: CollisionCheckerContext, q: numpy.ndarray[numpy.float64[m, 1]]) -> pydrake.systems.framework.Context: ...
    def UpdatePositions(self, q: numpy.ndarray[numpy.float64[m, 1]], context_number: Optional[int] = ...) -> pydrake.systems.framework.Context: ...
    def distance_and_interpolation_provider(self) -> DistanceAndInterpolationProvider: ...
    def edge_step_size(self) -> float: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.RigidBody: ...
    def model(self) -> RobotDiagram: ...
    def model_context(self, context_number: Optional[int] = ...) -> CollisionCheckerContext: ...
    def num_allocated_contexts(self) -> int: ...
    def plant(self) -> pydrake.multibody.plant.MultibodyPlant: ...
    def plant_context(self, context_number: Optional[int] = ...) -> pydrake.systems.framework.Context: ...
    def robot_model_instances(self) -> List[pydrake.multibody.tree.ModelInstanceIndex]: ...
    def set_edge_step_size(self, edge_step_size: float) -> None: ...
    def __copy__(self) -> CollisionChecker: ...
    def __deepcopy__(self, arg0: dict) -> CollisionChecker: ...

class CollisionCheckerContext:
    def __init__(self, model: RobotDiagram) -> None: ...
    def Clone(self) -> CollisionCheckerContext: ...
    def GetQueryObject(self) -> pydrake.geometry.QueryObject: ...
    def model_context(self) -> pydrake.systems.framework.Context: ...
    def plant_context(self) -> pydrake.systems.framework.Context: ...
    def scene_graph_context(self) -> pydrake.systems.framework.Context: ...
    def __copy__(self) -> CollisionCheckerContext: ...
    def __deepcopy__(self, arg0: dict) -> CollisionCheckerContext: ...

class CollisionCheckerParams:
    configuration_distance_function: Callable[[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, 1]]], float]
    distance_and_interpolation_provider: DistanceAndInterpolationProvider
    edge_step_size: float
    env_collision_padding: float
    implicit_context_parallelism: pydrake.common.Parallelism
    model: RobotDiagram
    robot_model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]
    self_collision_padding: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, **kwargs) -> None: ...

class DirectCollocation(MultipleShooting):
    def __init__(self, system: pydrake.systems.framework.System, context: pydrake.systems.framework.Context, num_time_samples: int, minimum_time_step: float, maximum_time_step: float, input_port_index: Union[pydrake.systems.framework.InputPortSelection, pydrake.systems.framework.InputPortIndex] = ..., assume_non_continuous_states_are_fixed: bool = ..., prog: pydrake.solvers.MathematicalProgram = ...) -> None: ...

class DirectCollocationConstraint(pydrake.solvers.Constraint):
    def __init__(self, system: pydrake.systems.framework.System, context: pydrake.systems.framework.Context, input_port_index: Union[pydrake.systems.framework.InputPortSelection, pydrake.systems.framework.InputPortIndex] = ..., assume_non_continuous_states_are_fixed: bool = ...) -> None: ...

class DirectTranscription(MultipleShooting):
    class TimeStep:
        value: float
        def __init__(self, value: float) -> None: ...
    @overload
    def __init__(self, system: pydrake.systems.framework.System, context: pydrake.systems.framework.Context, num_time_samples: int, input_port_index: Union[pydrake.systems.framework.InputPortSelection, pydrake.systems.framework.InputPortIndex] = ...) -> None: ...
    @overload
    def __init__(self, system: pydrake.systems.framework.System, context: pydrake.systems.framework.Context, num_time_samples: int, fixed_time_step: DirectTranscription.TimeStep, input_port_index: Union[pydrake.systems.framework.InputPortSelection, pydrake.systems.framework.InputPortIndex] = ...) -> None: ...

class DistanceAndInterpolationProvider:
    def __init__(self, *args, **kwargs) -> None: ...
    def ComputeConfigurationDistance(self, arg0: numpy.ndarray[numpy.float64[m, 1]], arg1: numpy.ndarray[numpy.float64[m, 1]]) -> float: ...
    def InterpolateBetweenConfigurations(self, arg0: numpy.ndarray[numpy.float64[m, 1]], arg1: numpy.ndarray[numpy.float64[m, 1]], arg2: float) -> numpy.ndarray[numpy.float64[m, 1]]: ...

class EdgeMeasure:
    @overload
    def __init__(self, distance: float, alpha: float) -> None: ...
    @overload
    def __init__(self, other: EdgeMeasure) -> None: ...
    def alpha(self) -> float: ...
    def alpha_or(self, default_value: float) -> float: ...
    def completely_free(self) -> bool: ...
    def distance(self) -> float: ...
    def partially_free(self) -> bool: ...
    def __copy__(self) -> EdgeMeasure: ...
    def __deepcopy__(self, arg0: dict) -> EdgeMeasure: ...

class GcsTrajectoryOptimization:
    class EdgesBetweenSubgraphs:
        def __init__(self, *args, **kwargs) -> None: ...
        def AddPathContinuityConstraints(self, continuity_order: int) -> None: ...
        def AddVelocityBounds(self, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
        def AddZeroDerivativeConstraints(self, derivative_order: int) -> None: ...

    class Subgraph:
        def __init__(self, *args, **kwargs) -> None: ...
        def AddPathContinuityConstraints(self, continuity_order: int) -> None: ...
        @overload
        def AddPathLengthCost(self, weight_matrix: numpy.ndarray[numpy.float64[m, n]]) -> None: ...
        @overload
        def AddPathLengthCost(self, weight: float = ...) -> None: ...
        def AddTimeCost(self, weight: float = ...) -> None: ...
        def AddVelocityBounds(self, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
        def Vertices(self) -> List[pydrake.geometry.optimization.GraphOfConvexSets.Vertex]: ...
        def name(self) -> str: ...
        def order(self) -> int: ...
        def regions(self) -> object: ...
        def size(self) -> int: ...
    def __init__(self, num_positions: int, continuous_revolute_joints: List[int] = ...) -> None: ...
    def AddEdges(self, from_subgraph: GcsTrajectoryOptimization.Subgraph, to_subgraph: GcsTrajectoryOptimization.Subgraph, subspace: pydrake.geometry.optimization.ConvexSet = ...) -> GcsTrajectoryOptimization.EdgesBetweenSubgraphs: ...
    def AddPathContinuityConstraints(self, continuity_order: int) -> None: ...
    @overload
    def AddPathLengthCost(self, weight_matrix: numpy.ndarray[numpy.float64[m, n]]) -> None: ...
    @overload
    def AddPathLengthCost(self, weight: float = ...) -> None: ...
    @overload
    def AddRegions(self, regions: List[pydrake.geometry.optimization.ConvexSet], edges_between_regions: List[Tuple[int, int]], order: int, h_min: float = ..., h_max: float = ..., name: str = ..., edge_offsets: Optional[List[numpy.ndarray[numpy.float64[m, 1]]]] = ...) -> GcsTrajectoryOptimization.Subgraph: ...
    @overload
    def AddRegions(self, regions: List[pydrake.geometry.optimization.ConvexSet], order: int, h_min: float = ..., h_max: float = ..., name: str = ...) -> GcsTrajectoryOptimization.Subgraph: ...
    def AddTimeCost(self, weight: float = ...) -> None: ...
    def AddVelocityBounds(self, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def GetEdgesBetweenSubgraphs(self) -> List[GcsTrajectoryOptimization.EdgesBetweenSubgraphs]: ...
    def GetGraphvizString(self, result: Optional[pydrake.solvers.MathematicalProgramResult] = ..., show_slack: bool = ..., precision: int = ..., scientific: bool = ...) -> str: ...
    def GetSubgraphs(self) -> List[GcsTrajectoryOptimization.Subgraph]: ...
    @classmethod
    def NormalizeSegmentTimes(cls, trajectory: pydrake.trajectories.CompositeTrajectory) -> pydrake.trajectories.CompositeTrajectory: ...
    def RemoveSubgraph(self, subgraph: GcsTrajectoryOptimization.Subgraph) -> None: ...
    @overload
    def SolveConvexRestriction(self, active_vertices: List[pydrake.geometry.optimization.GraphOfConvexSets.Vertex], options: pydrake.geometry.optimization.GraphOfConvexSetsOptions = ...) -> Tuple[pydrake.trajectories.CompositeTrajectory, pydrake.solvers.MathematicalProgramResult]: ...
    @overload
    def SolveConvexRestriction(self) -> Any: ...
    def SolvePath(self, source: GcsTrajectoryOptimization.Subgraph, target: GcsTrajectoryOptimization.Subgraph, options: pydrake.geometry.optimization.GraphOfConvexSetsOptions = ...) -> Tuple[pydrake.trajectories.CompositeTrajectory, pydrake.solvers.MathematicalProgramResult]: ...
    def continuous_revolute_joints(self) -> List[int]: ...
    def graph_of_convex_sets(self) -> pydrake.geometry.optimization.GraphOfConvexSets: ...
    def num_positions(self) -> int: ...

class IrisFromCliqueCoverOptions:
    coverage_termination_threshold: float
    iris_options: pydrake.geometry.optimization.IrisOptions
    iteration_limit: int
    minimum_clique_size: int
    num_points_per_coverage_check: int
    num_points_per_visibility_round: int
    parallelism: pydrake.common.Parallelism
    point_in_set_tol: float
    rank_tol_for_minimum_volume_circumscribed_ellipsoid: float
    def __init__(self) -> None: ...

class KinematicTrajectoryOptimization:
    @overload
    def __init__(self, num_positions: int, num_control_points: int, spline_order: int = ..., duration: float = ...) -> None: ...
    @overload
    def __init__(self, trajectory: pydrake.trajectories.BsplineTrajectory) -> None: ...
    def AddAccelerationBounds(self, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -> List[List[pydrake.solvers.BindingTConstraintU]]: ...
    def AddDurationConstraint(self, lb: Optional[float], ub: Optional[float]) -> pydrake.solvers.BindingTBoundingBoxConstraintU: ...
    def AddDurationCost(self, weight: float = ...) -> pydrake.solvers.BindingTLinearCostU: ...
    def AddJerkBounds(self, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -> List[List[pydrake.solvers.BindingTConstraintU]]: ...
    def AddPathAccelerationConstraint(self, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], s: float) -> pydrake.solvers.BindingTLinearConstraintU: ...
    def AddPathLengthCost(self, weight: float = ..., use_conic_constraint: bool = ...) -> List[pydrake.solvers.BindingTCostU]: ...
    @overload
    def AddPathPositionConstraint(self, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], s: float) -> pydrake.solvers.BindingTLinearConstraintU: ...
    @overload
    def AddPathPositionConstraint(self, constraint: pydrake.solvers.Constraint, s: float) -> pydrake.solvers.BindingTConstraintU: ...
    def AddPathVelocityConstraint(self, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], s: float) -> pydrake.solvers.BindingTLinearConstraintU: ...
    def AddPositionBounds(self, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -> List[pydrake.solvers.BindingTBoundingBoxConstraintU]: ...
    def AddVelocityBounds(self, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -> List[pydrake.solvers.BindingTLinearConstraintU]: ...
    def AddVelocityConstraintAtNormalizedTime(self, constraint: pydrake.solvers.Constraint, s: float) -> pydrake.solvers.BindingTConstraintU: ...
    def ReconstructTrajectory(self, result: pydrake.solvers.MathematicalProgramResult) -> pydrake.trajectories.BsplineTrajectory: ...
    def SetInitialGuess(self, trajectory: pydrake.trajectories.BsplineTrajectory) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis: ...
    def control_points(self) -> numpy.ndarray[object[m, n]]: ...
    def duration(self) -> pydrake.symbolic.Variable: ...
    def get_mutable_prog(self) -> pydrake.solvers.MathematicalProgram: ...
    def num_control_points(self) -> int: ...
    def num_positions(self) -> int: ...
    def prog(self) -> pydrake.solvers.MathematicalProgram: ...

class LinearDistanceAndInterpolationProvider(DistanceAndInterpolationProvider):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, distance_weights: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant, joint_distance_weights: Dict[pydrake.multibody.tree.JointIndex, numpy.ndarray[numpy.float64[m, 1]]]) -> None: ...
    def distance_weights(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def quaternion_dof_start_indices(self) -> List[int]: ...

class MaxCliqueSolverBase:
    def __init__(self) -> None: ...
    def SolveMaxClique(self, adjacency_matrix: scipy.sparse.csc_matrix[bool]) -> numpy.ndarray[bool[m, 1]]: ...

class MaxCliqueSolverViaGreedy(MaxCliqueSolverBase):
    def __init__(self) -> None: ...

class MaxCliqueSolverViaMip(MaxCliqueSolverBase):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, initial_guess: Optional[numpy.ndarray[numpy.float64[m, 1]]], solver_options: pydrake.solvers.SolverOptions) -> None: ...
    def GetInitialGuess(self) -> Optional[numpy.ndarray[numpy.float64[m, 1]]]: ...
    def GetSolverOptions(self) -> pydrake.solvers.SolverOptions: ...
    def SetInitialGuess(self, initial_guess: Optional[numpy.ndarray[numpy.float64[m, 1]]]) -> None: ...
    def SetSolverOptions(self, solver_options: pydrake.solvers.SolverOptions) -> None: ...

class MultipleShooting:
    def __init__(self, *args, **kwargs) -> None: ...
    def AddCompleteTrajectoryCallback(self, callback: Callable[[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], List[numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]]], None], names: List[str]) -> pydrake.solvers.BindingTVisualizationCallbackU: ...
    @overload
    def AddConstraintToAllKnotPoints(self, f: pydrake.symbolic.Formula) -> List[pydrake.solvers.BindingTConstraintU]: ...
    @overload
    def AddConstraintToAllKnotPoints(self, f: numpy.ndarray[object[m, 1]]) -> List[pydrake.solvers.BindingTConstraintU]: ...
    @overload
    def AddConstraintToAllKnotPoints(self, constraint: pydrake.solvers.BoundingBoxConstraint, vars: numpy.ndarray[object[m, 1]]) -> List[pydrake.solvers.BindingTBoundingBoxConstraintU]: ...
    @overload
    def AddConstraintToAllKnotPoints(self, constraint: pydrake.solvers.LinearEqualityConstraint, vars: numpy.ndarray[object[m, 1]]) -> List[pydrake.solvers.BindingTLinearEqualityConstraintU]: ...
    @overload
    def AddConstraintToAllKnotPoints(self, constraint: pydrake.solvers.LinearConstraint, vars: numpy.ndarray[object[m, 1]]) -> List[pydrake.solvers.BindingTLinearConstraintU]: ...
    @overload
    def AddConstraintToAllKnotPoints(self, constraint: pydrake.solvers.Constraint, vars: numpy.ndarray[object[m, 1]]) -> List[pydrake.solvers.BindingTConstraintU]: ...
    def AddDurationBounds(self, lower_bound: float, upper_bound: float) -> pydrake.solvers.BindingTLinearConstraintU: ...
    def AddEqualTimeIntervalsConstraints(self) -> List[pydrake.solvers.BindingTLinearConstraintU]: ...
    @overload
    def AddFinalCost(self, e: pydrake.symbolic.Expression) -> pydrake.solvers.BindingTCostU: ...
    @overload
    def AddFinalCost(self, matrix: numpy.ndarray[object[m, n], flags.f_contiguous]) -> pydrake.solvers.BindingTCostU: ...
    def AddInputTrajectoryCallback(self, callback: Callable[[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]], None]) -> pydrake.solvers.BindingTVisualizationCallbackU: ...
    @overload
    def AddRunningCost(self, g: pydrake.symbolic.Expression) -> None: ...
    @overload
    def AddRunningCost(self, g: numpy.ndarray[object[m, n], flags.f_contiguous]) -> None: ...
    def AddStateTrajectoryCallback(self, callback: Callable[[numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]], None]) -> pydrake.solvers.BindingTVisualizationCallbackU: ...
    def AddTimeIntervalBounds(self, lower_bound: float, upper_bound: float) -> pydrake.solvers.BindingTBoundingBoxConstraintU: ...
    def GetInputSamples(self, result: pydrake.solvers.MathematicalProgramResult) -> numpy.ndarray[numpy.float64[m, n]]: ...
    def GetSampleTimes(self, result: pydrake.solvers.MathematicalProgramResult) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def GetSequentialVariableAtIndex(self, name: str, index: int) -> numpy.ndarray[object[m, 1]]: ...
    def GetSequentialVariableSamples(self, result: pydrake.solvers.MathematicalProgramResult, name: str) -> numpy.ndarray[numpy.float64[m, n]]: ...
    def GetStateSamples(self, result: pydrake.solvers.MathematicalProgramResult) -> numpy.ndarray[numpy.float64[m, n]]: ...
    def NewSequentialVariable(self, rows: int, name: str) -> numpy.ndarray[object[m, 1]]: ...
    def ReconstructInputTrajectory(self, result: pydrake.solvers.MathematicalProgramResult) -> pydrake.trajectories.PiecewisePolynomial: ...
    def ReconstructStateTrajectory(self, result: pydrake.solvers.MathematicalProgramResult) -> pydrake.trajectories.PiecewisePolynomial: ...
    def SetInitialTrajectory(self, traj_init_u: pydrake.trajectories.PiecewisePolynomial, traj_init_x: pydrake.trajectories.PiecewisePolynomial) -> None: ...
    def final_state(self) -> numpy.ndarray[object[m, 1]]: ...
    def fixed_time_step(self) -> float: ...
    def initial_state(self) -> numpy.ndarray[object[m, 1]]: ...
    @overload
    def input(self) -> numpy.ndarray[object[m, 1]]: ...
    @overload
    def input(self, index: int) -> numpy.ndarray[object[m, 1]]: ...
    def prog(self) -> pydrake.solvers.MathematicalProgram: ...
    @overload
    def state(self) -> numpy.ndarray[object[m, 1]]: ...
    @overload
    def state(self, index: int) -> numpy.ndarray[object[m, 1]]: ...
    def time(self) -> numpy.ndarray[object[1, 1]]: ...
    def time_step(self, index: int) -> numpy.ndarray[object[1, 1]]: ...

class RobotClearance:
    @overload
    def __init__(self, num_positions: int) -> None: ...
    @overload
    def __init__(self, other: RobotClearance) -> None: ...
    def Append(self, *args, **kwargs): ...
    def Reserve(self, size: int) -> None: ...
    def collision_types(self, *args, **kwargs): ...
    def distances(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def jacobians(self) -> numpy.ndarray[numpy.float64[m, n], flags.c_contiguous]: ...
    def mutable_jacobians(self) -> numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous]: ...
    def num_positions(self) -> int: ...
    def other_indices(self) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def robot_indices(self) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def size(self) -> int: ...
    def __copy__(self) -> RobotClearance: ...
    def __deepcopy__(self, arg0: dict) -> RobotClearance: ...

class RobotCollisionType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kEnvironmentAndSelfCollision: ClassVar[RobotCollisionType] = ...
    kEnvironmentCollision: ClassVar[RobotCollisionType] = ...
    kNoCollision: ClassVar[RobotCollisionType] = ...
    kSelfCollision: ClassVar[RobotCollisionType] = ...
    def __init__(self, value: int) -> None: ...
    def MakeUpdated(self, *args, **kwargs): ...
    def __del__(self, *args, **kwargs) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RobotDiagram(pydrake.systems.framework.Diagram):
    def __init__(self, *args, **kwargs) -> None: ...
    def mutable_plant_context(self, root_context: pydrake.systems.framework.Context) -> pydrake.systems.framework.Context: ...
    def mutable_scene_graph(self) -> pydrake.geometry.SceneGraph: ...
    def mutable_scene_graph_context(self, root_context: pydrake.systems.framework.Context) -> pydrake.systems.framework.Context: ...
    @overload
    def plant(self) -> pydrake.multibody.plant.MultibodyPlant: ...
    @overload
    def plant(self, readonly) -> Any: ...
    def plant_context(self, root_context: pydrake.systems.framework.Context) -> pydrake.systems.framework.Context: ...
    def scene_graph(self) -> pydrake.geometry.SceneGraph: ...
    def scene_graph_context(self, root_context: pydrake.systems.framework.Context) -> pydrake.systems.framework.Context: ...

class RobotDiagramBuilder:
    def __init__(self, time_step: float = ...) -> None: ...
    def Build(self) -> RobotDiagram: ...
    def IsDiagramBuilt(self) -> bool: ...
    def builder(self) -> pydrake.systems.framework.DiagramBuilder: ...
    def parser(self) -> pydrake.multibody.parsing.Parser: ...
    @overload
    def plant(self) -> pydrake.multibody.plant.MultibodyPlant: ...
    @overload
    def plant(self, mutable) -> Any: ...
    def scene_graph(self) -> pydrake.geometry.SceneGraph: ...

class RobotDiagramBuilder_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float = ...) -> None: ...
    def Build(self) -> RobotDiagram_TAutoDiffXdU: ...
    def IsDiagramBuilt(self) -> bool: ...
    def builder(self) -> pydrake.systems.framework.DiagramBuilder_TAutoDiffXdU: ...
    @overload
    def plant(self) -> pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU: ...
    @overload
    def plant(self, mutable) -> Any: ...
    def scene_graph(self) -> pydrake.geometry.SceneGraph_TAutoDiffXdU: ...

class RobotDiagramBuilder_ð“£Expressionð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float = ...) -> None: ...
    def Build(self) -> RobotDiagram_TExpressionU: ...
    def IsDiagramBuilt(self) -> bool: ...
    def builder(self) -> pydrake.systems.framework.DiagramBuilder_TExpressionU: ...
    @overload
    def plant(self) -> pydrake.multibody.plant.MultibodyPlant_TExpressionU: ...
    @overload
    def plant(self, mutable) -> Any: ...
    def scene_graph(self) -> pydrake.geometry.SceneGraph_TExpressionU: ...

class RobotDiagram_ð“£AutoDiffXdð“¤(pydrake.systems.framework.Diagram_TAutoDiffXdU):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def mutable_plant_context(self, root_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> pydrake.systems.framework.Context_TAutoDiffXdU: ...
    def mutable_scene_graph(self) -> pydrake.geometry.SceneGraph_TAutoDiffXdU: ...
    def mutable_scene_graph_context(self, root_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> pydrake.systems.framework.Context_TAutoDiffXdU: ...
    @overload
    def plant(self) -> pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU: ...
    @overload
    def plant(self, readonly) -> Any: ...
    def plant_context(self, root_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> pydrake.systems.framework.Context_TAutoDiffXdU: ...
    def scene_graph(self) -> pydrake.geometry.SceneGraph_TAutoDiffXdU: ...
    def scene_graph_context(self, root_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> pydrake.systems.framework.Context_TAutoDiffXdU: ...

class RobotDiagram_ð“£Expressionð“¤(pydrake.systems.framework.Diagram_TExpressionU):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def mutable_plant_context(self, root_context: pydrake.systems.framework.Context_TExpressionU) -> pydrake.systems.framework.Context_TExpressionU: ...
    def mutable_scene_graph(self) -> pydrake.geometry.SceneGraph_TExpressionU: ...
    def mutable_scene_graph_context(self, root_context: pydrake.systems.framework.Context_TExpressionU) -> pydrake.systems.framework.Context_TExpressionU: ...
    @overload
    def plant(self) -> pydrake.multibody.plant.MultibodyPlant_TExpressionU: ...
    @overload
    def plant(self, readonly) -> Any: ...
    def plant_context(self, root_context: pydrake.systems.framework.Context_TExpressionU) -> pydrake.systems.framework.Context_TExpressionU: ...
    def scene_graph(self) -> pydrake.geometry.SceneGraph_TExpressionU: ...
    def scene_graph_context(self, root_context: pydrake.systems.framework.Context_TExpressionU) -> pydrake.systems.framework.Context_TExpressionU: ...

class SceneGraphCollisionChecker(CollisionChecker):
    def __init__(self, *args, **kwargs) -> None: ...

class UnimplementedCollisionChecker(CollisionChecker):
    def __init__(self, *args, **kwargs) -> None: ...

class _TemporaryName_N5drake8planning12RobotDiagramIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.Diagram_TAutoDiffXdU):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def mutable_plant_context(self, root_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> pydrake.systems.framework.Context_TAutoDiffXdU: ...
    def mutable_scene_graph(self) -> pydrake.geometry.SceneGraph_TAutoDiffXdU: ...
    def mutable_scene_graph_context(self, root_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> pydrake.systems.framework.Context_TAutoDiffXdU: ...
    @overload
    def plant(self) -> pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU: ...
    @overload
    def plant(self, readonly) -> Any: ...
    def plant_context(self, root_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> pydrake.systems.framework.Context_TAutoDiffXdU: ...
    def scene_graph(self) -> pydrake.geometry.SceneGraph_TAutoDiffXdU: ...
    def scene_graph_context(self, root_context: pydrake.systems.framework.Context_TAutoDiffXdU) -> pydrake.systems.framework.Context_TAutoDiffXdU: ...

class _TemporaryName_N5drake8planning12RobotDiagramINS_8symbolic10ExpressionEEE(pydrake.systems.framework.Diagram_TExpressionU):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def mutable_plant_context(self, root_context: pydrake.systems.framework.Context_TExpressionU) -> pydrake.systems.framework.Context_TExpressionU: ...
    def mutable_scene_graph(self) -> pydrake.geometry.SceneGraph_TExpressionU: ...
    def mutable_scene_graph_context(self, root_context: pydrake.systems.framework.Context_TExpressionU) -> pydrake.systems.framework.Context_TExpressionU: ...
    @overload
    def plant(self) -> pydrake.multibody.plant.MultibodyPlant_TExpressionU: ...
    @overload
    def plant(self, readonly) -> Any: ...
    def plant_context(self, root_context: pydrake.systems.framework.Context_TExpressionU) -> pydrake.systems.framework.Context_TExpressionU: ...
    def scene_graph(self) -> pydrake.geometry.SceneGraph_TExpressionU: ...
    def scene_graph_context(self, root_context: pydrake.systems.framework.Context_TExpressionU) -> pydrake.systems.framework.Context_TExpressionU: ...

class _TemporaryName_N5drake8planning19RobotDiagramBuilderIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float = ...) -> None: ...
    def Build(self) -> RobotDiagram_TAutoDiffXdU: ...
    def IsDiagramBuilt(self) -> bool: ...
    def builder(self) -> pydrake.systems.framework.DiagramBuilder_TAutoDiffXdU: ...
    @overload
    def plant(self) -> pydrake.multibody.plant.MultibodyPlant_TAutoDiffXdU: ...
    @overload
    def plant(self, mutable) -> Any: ...
    def scene_graph(self) -> pydrake.geometry.SceneGraph_TAutoDiffXdU: ...

class _TemporaryName_N5drake8planning19RobotDiagramBuilderINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float = ...) -> None: ...
    def Build(self) -> RobotDiagram_TExpressionU: ...
    def IsDiagramBuilt(self) -> bool: ...
    def builder(self) -> pydrake.systems.framework.DiagramBuilder_TExpressionU: ...
    @overload
    def plant(self) -> pydrake.multibody.plant.MultibodyPlant_TExpressionU: ...
    @overload
    def plant(self, mutable) -> Any: ...
    def scene_graph(self) -> pydrake.geometry.SceneGraph_TExpressionU: ...

def AddDirectCollocationConstraint(constraint: DirectCollocationConstraint, time_step: numpy.ndarray[object[m, 1]], state: numpy.ndarray[object[m, 1]], next_state: numpy.ndarray[object[m, 1]], input: numpy.ndarray[object[m, 1]], next_input: numpy.ndarray[object[m, 1]], prog: pydrake.solvers.MathematicalProgram) -> pydrake.solvers.BindingTConstraintU: ...
def GetContinuousRevoluteJointIndices(plant: pydrake.multibody.plant.MultibodyPlant) -> List[int]: ...
def IrisInConfigurationSpaceFromCliqueCover(checker: CollisionChecker, options: IrisFromCliqueCoverOptions, generator: pydrake.common.RandomGenerator, sets: List[pydrake.geometry.optimization.HPolyhedron], max_clique_solver: MaxCliqueSolverBase = ...) -> List[pydrake.geometry.optimization.HPolyhedron]: ...
def MakeBodyShapeDescription(plant: pydrake.multibody.plant.MultibodyPlant, plant_context: pydrake.systems.framework.Context, geometry_id: pydrake.geometry.GeometryId) -> BodyShapeDescription: ...
def VisibilityGraph(checker: CollisionChecker, points: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], parallelize: pydrake.common.Parallelism = ...) -> scipy.sparse.csc_matrix[bool]: ...
